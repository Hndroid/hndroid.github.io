<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bai HongHua</title>
  
  
  <link href="https://hndroid.github.io/atom.xml" rel="self"/>
  
  <link href="https://hndroid.github.io/"/>
  <updated>2021-07-05T15:04:00.520Z</updated>
  <id>https://hndroid.github.io/</id>
  
  <author>
    <name>Bai HongHua</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Framework篇--开机启动init进程</title>
    <link href="https://hndroid.github.io/2021/07/05/Framework%E7%AF%87-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8init%E8%BF%9B%E7%A8%8B/"/>
    <id>https://hndroid.github.io/2021/07/05/Framework%E7%AF%87-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8init%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-07-05T14:50:46.000Z</published>
    <updated>2021-07-05T15:04:00.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于 Android 6.0.0 源码进行分析</p></blockquote><p><code>init</code> 进程涉及的源码：</p><ul><li><code>/system/core/init/init.cpp</code></li></ul><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>init</code> 进程是 Linux 系统中用户空间的第一个进程，其进程号为 1。在 <code>Kernel</code> 启动后，在用户空间启动 <code>init</code> 进程，并调用 <code>init</code> 中的 <code>main()</code> 方法执行 <code>init</code> 进程的职责。对于 <code>init</code> 进程的功能，通过分析其 <code>main()</code> 方法的逻辑，主要可以划分为以下 5 部分：</p><ul><li>挂载、创建所系统运行所需要的目录，如 <code>tmpfs</code>、<code>pts</code>、<code>proc</code>…</li><li>加载属性服务；</li><li>解析并运行所有的 init.rc 相关的文件；</li><li>化身为守护进程，处理signal、property和keychord等服务；</li></ul><span id="more"></span><p><img src="/.io//image-20210704115128054.png"></p><p>接下来，让我们一起进入 Android Framework 源码的世界吧！</p><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>[-&gt;init.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="built_in">basename</span>(argv[<span class="number">0</span>]), <span class="string">&quot;ueventd&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ueventd_main</span>(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="built_in">basename</span>(argv[<span class="number">0</span>]), <span class="string">&quot;watchdogd&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//watchdogd 的作用 &#123;崩溃 &amp; 死机&#125; =》重启</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">watchdogd_main</span>(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the umask.</span></span><br><span class="line">    <span class="comment">// 设置文件属性</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add_environment</span>(<span class="string">&quot;PATH&quot;</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> is_first_stage = (argc == <span class="number">1</span>) || (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--second-stage&quot;</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line">    <span class="comment">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        <span class="built_in">mount</span>(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="string">&quot;mode=0755&quot;</span>);</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/socket&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="built_in">mount</span>(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">mount</span>(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">mount</span>(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We must have some place other than / to create the device nodes for</span></span><br><span class="line">    <span class="comment">// kmsg and null, otherwise we won&#x27;t be able to remount / read-only</span></span><br><span class="line">    <span class="comment">// later on. Now that tmpfs is mounted on /dev, we can actually talk</span></span><br><span class="line">    <span class="comment">// to the outside world.</span></span><br><span class="line">    <span class="built_in">open_devnull_stdio</span>();</span><br><span class="line"><span class="comment">// 初始化内核log</span></span><br><span class="line">    <span class="built_in">klog_init</span>();</span><br><span class="line"><span class="comment">// 给内核 log 设置日志 5，表示当 log 的日志小于 5 时则会把日志输出到 kernel log 上，</span></span><br><span class="line"><span class="comment">// 默认的日志等级为 3；KLOG_DEFAULT_LEVEL ==》3</span></span><br><span class="line">    <span class="built_in">klog_set_level</span>(KLOG_NOTICE_LEVEL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NOTICE</span>(<span class="string">&quot;init%s started!\n&quot;</span>, is_first_stage ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; second stage&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is_first_stage) &#123;</span><br><span class="line">        <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">        <span class="built_in">close</span>(<span class="built_in">open</span>(<span class="string">&quot;/dev/.booting&quot;</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line"><span class="comment">// 创建一块共享的内存空间，用于属性服务</span></span><br><span class="line">        <span class="built_in">property_init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If arguments are passed both on the command line and in DT,</span></span><br><span class="line">        <span class="comment">// properties set in DT always have priority over the command-line ones.</span></span><br><span class="line">        <span class="built_in">process_kernel_dt</span>();</span><br><span class="line">        <span class="built_in">process_kernel_cmdline</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propogate the kernel variables to internal variables</span></span><br><span class="line">        <span class="comment">// used by init as well as the current required properties.</span></span><br><span class="line">        <span class="built_in">export_kernel_boot_props</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up SELinux, including loading the SELinux policy if we&#x27;re in the kernel domain.</span></span><br><span class="line">    <span class="built_in">selinux_initialize</span>(is_first_stage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re in the kernel domain, re-exec init to transition to the init domain now</span></span><br><span class="line">    <span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">restorecon</span>(<span class="string">&quot;/init&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;restorecon failed: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">security_failure</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>* args[] = &#123; path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">&quot;--second-stage&quot;</span>), <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">execv</span>(path, args) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;execv(\&quot;%s\&quot;) failed: %s\n&quot;</span>, path, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">security_failure</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These directories were necessarily created before initial policy load</span></span><br><span class="line">    <span class="comment">// and therefore need their security context restored to the proper value.</span></span><br><span class="line">    <span class="comment">// This must happen before /dev is populated by ueventd.</span></span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;Running restorecon...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">restorecon</span>(<span class="string">&quot;/dev&quot;</span>);</span><br><span class="line">    <span class="built_in">restorecon</span>(<span class="string">&quot;/dev/socket&quot;</span>);</span><br><span class="line">    <span class="built_in">restorecon</span>(<span class="string">&quot;/dev/__properties__&quot;</span>);</span><br><span class="line">    <span class="built_in">restorecon_recursive</span>(<span class="string">&quot;/sys&quot;</span>);</span><br><span class="line"><span class="comment">// 初始化epoll功能</span></span><br><span class="line">    epoll_fd = <span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">ERROR</span>(<span class="string">&quot;epoll_create1 failed: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理子进程挂掉的情况，主要的核心有二：</span></span><br><span class="line"><span class="comment">// 1.通过挂掉的 pid 找到对应的 svc，将僵尸进程 kill 掉，达到释放资源的目的；</span></span><br><span class="line"><span class="comment">// 2.根据标志位确认是否重启，如果重启则设置属性&quot;init.svc.&#123;$service_name&#125;&quot; &quot;restarting&quot;，供别处获取；</span></span><br><span class="line">    <span class="built_in">signal_handler_init</span>();</span><br><span class="line"><span class="comment">// 加载default.prop文件</span></span><br><span class="line">    <span class="built_in">property_load_boot_defaults</span>();</span><br><span class="line"><span class="comment">// 启动属性服务器，此处会调用epoll_ctl设置property fd可读的回调函数</span></span><br><span class="line">    <span class="built_in">start_property_service</span>();</span><br><span class="line">    <span class="comment">// 解析init.rc文件</span></span><br><span class="line">    <span class="built_in">init_parse_config_file</span>(<span class="string">&quot;/init.rc&quot;</span>);</span><br><span class="line"><span class="comment">// 执行rc文件中触发器为on early-init的语句</span></span><br><span class="line">    <span class="built_in">action_for_each_trigger</span>(<span class="string">&quot;early-init&quot;</span>, action_add_queue_tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">    <span class="built_in">queue_builtin_action</span>(wait_for_coldboot_done_action, <span class="string">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class="line">    <span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">    <span class="built_in">queue_builtin_action</span>(mix_hwrng_into_linux_rng_action, <span class="string">&quot;mix_hwrng_into_linux_rng&quot;</span>);</span><br><span class="line">    <span class="built_in">queue_builtin_action</span>(keychord_init_action, <span class="string">&quot;keychord_init&quot;</span>);</span><br><span class="line"><span class="comment">// 设备组合键的初始化操作，此处会调用epoll_ctl设置keychord fd可读的回调函数</span></span><br><span class="line"><span class="comment">// console_init_action ==》这便是开机显示的底部带ANDROID字样的画面的回调函数</span></span><br><span class="line">    <span class="built_in">queue_builtin_action</span>(console_init_action, <span class="string">&quot;console_init&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">    <span class="comment">// 执行rc文件中触发器为on init的语句</span></span><br><span class="line">    <span class="built_in">action_for_each_trigger</span>(<span class="string">&quot;init&quot;</span>, action_add_queue_tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line">    <span class="comment">// wasn&#x27;t ready immediately after wait_for_coldboot_done</span></span><br><span class="line">    <span class="built_in">queue_builtin_action</span>(mix_hwrng_into_linux_rng_action, <span class="string">&quot;mix_hwrng_into_linux_rng&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class="line">    <span class="keyword">char</span> bootmode[PROP_VALUE_MAX];</span><br><span class="line"><span class="comment">// 当处于充电模式，则charger加入执行队列；否则late-init加入队列。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">property_get</span>(<span class="string">&quot;ro.bootmode&quot;</span>, bootmode) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(bootmode, <span class="string">&quot;charger&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">action_for_each_trigger</span>(<span class="string">&quot;charger&quot;</span>, action_add_queue_tail);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">action_for_each_trigger</span>(<span class="string">&quot;late-init&quot;</span>, action_add_queue_tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">    <span class="comment">// 触发器为属性是否设置</span></span><br><span class="line">    <span class="built_in">queue_builtin_action</span>(queue_property_triggers_action, <span class="string">&quot;queue_property_triggers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// init化身守护进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!waiting_for_exec) &#123;</span><br><span class="line"><span class="comment">// 执行命令列表中的命令</span></span><br><span class="line">            <span class="built_in">execute_one_command</span>();</span><br><span class="line"><span class="comment">// 检查service_list中的所有服务，对于带有SVC_RESTARTING标志的服务，则都会调用其相应的</span></span><br><span class="line"><span class="comment">// restart_service_if_needed</span></span><br><span class="line">            <span class="built_in">restart_processes</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> timeout = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (process_needs_restart) &#123;</span><br><span class="line">            timeout = (process_needs_restart - <span class="built_in">gettime</span>()) * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">                timeout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">action_queue_empty</span>() || cur_action) &#123;</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">        <span class="built_in">bootchart_sample</span>(&amp;timeout);</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line"><span class="comment">// 循环等待事件发生，到这里，init 进程进入 epoll_wait 的状态</span></span><br><span class="line">        <span class="keyword">int</span> nr = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">epoll_wait</span>(epoll_fd, &amp;ev, <span class="number">1</span>, timeout));</span><br><span class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// ==》对应 klog_init(); </span></span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;epoll_wait failed: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用epoll_event事件存储的函数指针处理事件</span></span><br><span class="line">            ((<span class="built_in"><span class="keyword">void</span></span> (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h4><p>在 <code>init</code> 进程初始化的过程会分别挂载 <code>tmpfs</code>、<code>devpts</code>、<code>proc</code>、<code>sysfs</code> 文件系统。</p><p><em><strong>tmpfs文件系统</strong></em></p><p>tmpfs是一种虚拟内存文件系统，因此它会将所有的文件存储在虚拟内存中。并且tmpfs下的所有内容均为临时性的内容。tmpfs是一个独立的文件系统，不是块设备，只要挂接就可以使用。同时，mpfs是驻留在RAM的，因此它的内容是不持久的，断电后，tmpfs的内容就消失了，这也是被称作tmpfs的原因。</p><p><em><strong>devpts文件系统</strong></em></p><p> devpts文件系统为伪终端提供了一个标准接口，它的标准挂接点是/dev/pts。只要pty的主复合设备/dev/ptmx被打开，就会在/dev/pts下动态的创建一个新的pty设备文件。</p><p><em><strong>proc文件系统</strong></em></p><p><code>proc</code>文件系统是一个非常重要的虚拟文件系统，它可以看着是内核数据结构的接口，通过它我们可以获取到系统的信息，同时也可以在运行时修改特定的内核参数。</p><p><em><strong>sysfs文件系统</strong></em></p><p>与proc文件系统类似，sysfs文件系统也是一个不占有任何磁盘空间的虚拟文件系统。它通常被挂接在/sys目录下。sysfs文件系统是Linux2.6内核引入的，它把连接在系统上的设备和总线组织成为一个分级的文件，使得它们可以在用户空间存取。</p><h4 id="准备klog"><a href="#准备klog" class="headerlink" title="准备klog"></a>准备klog</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klog_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (klog_fd &gt;= <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">/* Already initialized */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核 log 文件，可以通过 cat /dev/kmsg 来查看系统 log 日志</span></span><br><span class="line">    <span class="comment">// O_CLOEXEC ==》原子性操作</span></span><br><span class="line">    klog_fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (klog_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mknod [选项]  设备名    设备类型     主设备号 次设备号</span></span><br><span class="line"><span class="comment">// 创建 __kmsg__   设备</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;/dev/__kmsg__&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mknod</span>(name, S_IFCHR | <span class="number">0600</span>, (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) | <span class="number">11</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        klog_fd = <span class="built_in">open</span>(name, O_WRONLY | O_CLOEXEC);</span><br><span class="line">        <span class="built_in">unlink</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过 <code>open</code> 函数打开 <code>/dev/kmsg</code> 设备节点。例如可以通过 <code>cat /dev/kmsg</code> 来打印内核的 <code>log</code> 日志。</p><p>然后通过 <code>klog_set_level(5)</code> 设备日志输出的条件。当日志小于 5 的时候，会输出日志到文件 <code>/dev/kmsg</code>。</p><h4 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h4><p>属性服务在 <code>init</code> 守护进程中运行。每一个客户端想要设置属性时，必须连接属性服务，再向其发送信息。属性服务会在共享内存中修改、创建属性。</p><blockquote><p>工作原理图：</p></blockquote><p><img src="/.io//image-20210704204043759.png"></p><p>[-&gt;\system\core\init\property_service.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 保证只初始化 /dev/__properties__ 一次</span></span><br><span class="line">    <span class="keyword">if</span> (property_area_initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    property_area_initialized = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 通过 mmap 初始化 /dev/__properties__</span></span><br><span class="line">    <span class="keyword">if</span> (__system_property_area_init()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pa_workspace.size = <span class="number">0</span>;</span><br><span class="line">    pa_workspace.fd = <span class="built_in">open</span>(PROP_FILENAME, O_RDONLY | O_NOFOLLOW | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (pa_workspace.fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">ERROR</span>(<span class="string">&quot;Failed to open %s: %s\n&quot;</span>, PROP_FILENAME, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，主要的核心的主要操作是在方法 <code>__system_property_area_init</code> 中：</p><ul><li>通过 <code>open</code> 打开 <code>/dev/__properties__</code> 文件；</li><li>通过 <code>mmap</code> 内存映射到进程中，并以共享内存的方式分配 <code>#define PA_SIZE (128 * 1024)</code> 大小的内存区域，这样其他进程就可以跨进程访问属性区域了；</li><li>然后把内存的首地址保存在全局变量 <code>__system_property_area__</code> 中，后续的增加或者修改属性都是基于该变量来计算位置。</li></ul><h5 id="1-0-start-property-service"><a href="#1-0-start-property-service" class="headerlink" title="#1.0 start_property_service"></a>#1.0 start_property_service</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_property_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建名字为 property_service 的 socket</span></span><br><span class="line">    property_set_fd = <span class="built_in">create_socket</span>(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,<span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (property_set_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">ERROR</span>(<span class="string">&quot;start_property_service socket creation failed: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">listen</span>(property_set_fd, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 通过 epoll_ctl 设置 property 文件描述符触发可读时的回调函数为 handle_property_set_fd</span></span><br><span class="line">    <span class="built_in">register_epoll_handler</span>(property_set_fd, handle_property_set_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> handle_property_set_fd 回调函数主要是针对 socket  接收的事件进行处理，同时在设置属性的时候，也会对属性名称进行检查是否合法。</p><h4 id="解析-init-rc-文件"><a href="#解析-init-rc-文件" class="headerlink" title="解析 init.rc 文件"></a>解析 init.rc 文件</h4><p>在 <code>init</code> 进程中，配置文件是指 <code>init.rc</code> 文件,其路径是：</p><blockquote><p>\system\core\rootdir\init.rc</p></blockquote><p>文件 <code>init.rc</code> 包含四种状态类被，分别是 Action、Commands、Services 和 Options。当 声明一个 Services 或 Action 的时候，它将隐式声明一个 section，它之后跟随的 Command 或者 Option 都属于这个 section。</p><p><em><strong>Action</strong></em></p><p>Action 就是在某种条件下触发的一系列命令，通常有一个 <code>trigger</code>，通过触发器 <code>trigger</code> ,即以 on 开头的语句来决定执行相应的 Service 的时机，具体的时机如下：</p><ul><li>on early-init：在初始化早期阶段触发；</li><li>on init：在初始化阶段触发；</li><li>on late-init：在初始化阶段触发；</li><li>on boot/charger：当系统启动/充电时触发；</li><li>on property:<key>=<value>：当属性值满足条件时触发；</value></key></li></ul><p>通常的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt;</span><br><span class="line">   &lt;command&gt;</span><br><span class="line">   &lt;command&gt;</span><br></pre></td></tr></table></figure><p>如下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">    # Set init <span class="keyword">and</span> its forked children<span class="number">&#x27;</span>s oom_adj.</span><br><span class="line">    write /proc/<span class="number">1</span>/oom_score_adj <span class="number">-1000</span></span><br><span class="line">    # Set the security context of /adb_keys <span class="keyword">if</span> present.</span><br><span class="line">    restorecon /adb_keys</span><br><span class="line">    start ueventd</span><br></pre></td></tr></table></figure><p>下面列举常用的 <strong>command</strong> 命令：</p><ul><li>class_start <service_class_name>： 启动属于同一个class的所有服务；</service_class_name></li><li>start <service_name>： 启动指定的服务，若已启动则跳过；</service_name></li><li>stop <service_name>： 停止正在运行的服务;</service_name></li><li>setprop <name> <value>：设置属性值;</value></name></li><li>mkdir <path></path>：创建指定目录;</li><li>symlink <target> <sym_link>： 创建连接到<target>的<sym_link>符号链接；</sym_link></target></sym_link></target></li><li>write <path></path> <string>： 向文件path中写入字符串；</string></li><li>exec： fork并执行，会阻塞init进程直到程序完毕；</li><li>exprot <name> <name>：设定环境变量；</name></name></li><li>loglevel <level>：设置log级别；</level></li></ul><p><em><strong>Service</strong></em></p><p>服务Service，以 service开头，由init进程启动，一般运行在init的一个子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service在启动时会通过fork方式生成子进程。</p><p>Service  的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [&lt;argument&gt;]*</span><br><span class="line">&lt;option&gt;</span><br><span class="line">&lt;option&gt;</span><br></pre></td></tr></table></figure><p>如下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc</span><br><span class="line">    onrestart restart zygote</span><br></pre></td></tr></table></figure><p>在上述的例子中，<code>surfaceflinger</code> 表示为服务名，而 <code>/system/bin/surfaceflinger</code> 表示的是服务的执行路径。</p><p>其中，**option **是 Service 的修饰词，也可以理解为 Service 的可选项，和 <code>Service</code> 配合使用。主要包括以下的选项：</p><ul><li>critical：表示如果服务在 4 分钟重启的次数多于 4 次，则系统重启到 recovery mode；</li><li>disabled：表示服务不会自动重启，需要手动调用名字重启。</li><li>setEnv <name> <value>: 设置启动环境变量；</value></name></li><li>socket <name> <type> <permission> [<user> [<group>]]: 开启一个 unix 域的 socket，名字为 /dev/socket/<name>, <type>只能是 dgram 或者stream，<user> 和 <group> 默认为 0；</group></user></type></name></group></user></permission></type></name></li><li>user<username>: 表示将用户切换为 <username>, 用户名已经定义好了，只能是 /system/root;</username></username></li><li>group<groupname>:表示将组切换为<goupname></goupname></groupname></li><li>oneshot:表示这个 Service 只启动一次；</li><li>class<name>: 指定一个要启动的类，这个类中如果有多个 Service，将会被同时启动。默认的class 将会 “default”;</name></li><li>onrrestart: 在重启时执行一条命令；</li></ul><h5 id="分析-init-rc-的过程"><a href="#分析-init-rc-的过程" class="headerlink" title="分析 init.rc 的过程"></a>分析 init.rc 的过程</h5><p><code>init</code> 是在 <code>main</code> 方法中通过 <code>init_parse_config_file</code> 来解析 <code>init.rc</code> 文件的。整个解析的流程可以总结为：</p><blockquote><p>init_parse_config_file &gt;&gt; read_file &gt;&gt; parse_config</p></blockquote><p>其中 <code>init_parse_config_file </code> 、以及 <code>parse_config</code> 主要是通过 <code>for</code> 循环对文件 <code>init.rc</code> 的内容进行解析，以一行一行的形式进行读取。</p><p>最后会来到 <code>parse_config</code> 中对读取到的每一行进行解析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse_config</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fn, <span class="keyword">const</span> std::string&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span> <span class="title">import_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *args[INIT_PARSER_MAXARGS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nargs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    parse_state state;</span><br><span class="line">    state.filename = fn;</span><br><span class="line">    state.line = <span class="number">0</span>;</span><br><span class="line">    state.ptr = <span class="built_in">strdup</span>(data.<span class="built_in">c_str</span>());  <span class="comment">// <span class="doctag">TODO:</span> fix this code!</span></span><br><span class="line">    state.nexttoken = <span class="number">0</span>;</span><br><span class="line">    state.parse_line = parse_line_no_op;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list_init</span>(&amp;import_list);</span><br><span class="line">    state.priv = &amp;import_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">next_token</span>(&amp;state)) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_EOF: <span class="comment">// 文件尾</span></span><br><span class="line">            state.<span class="built_in">parse_line</span>(&amp;state, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">goto</span> parser_done;</span><br><span class="line">        <span class="keyword">case</span> T_NEWLINE: <span class="comment">// 新的一行</span></span><br><span class="line">            state.line++;</span><br><span class="line">            <span class="keyword">if</span> (nargs) &#123;</span><br><span class="line">                <span class="keyword">int</span> kw = <span class="built_in">lookup_keyword</span>(args[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">kw_is</span>(kw, SECTION)) &#123;</span><br><span class="line">                    state.<span class="built_in">parse_line</span>(&amp;state, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">parse_new_section</span>(&amp;state, kw, nargs, args);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    state.<span class="built_in">parse_line</span>(&amp;state, nargs, args);</span><br><span class="line">                &#125;</span><br><span class="line">                nargs = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_TEXT: <span class="comment">// 内容文本</span></span><br><span class="line">            <span class="keyword">if</span> (nargs &lt; INIT_PARSER_MAXARGS) &#123;</span><br><span class="line">                args[nargs++] = state.text;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中上面关键的代码是 <code>lookup_keyword</code> 主要是对每一行的第一个字符进行进行 <code>case</code> 判断。如常用的 service 和 on 经过 <code>lookup_keyword</code> 解析会返回 <code>K_service</code> 和 <code>K_on</code> ，随后通过 <code>kw_is(kw, type)</code>  判断是否属于 SECTION 类型，而在 <code>init.rc</code> 文件中只有 service 和 on 满足该类型。</p><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">...</span><br><span class="line">on init</span><br><span class="line"># Mount filesystems and start core system services.</span><br><span class="line">on late-init</span><br><span class="line">...</span><br><span class="line">on post-fs // 挂载文件系统</span><br><span class="line">...</span><br><span class="line">on post-fs-data  //挂载data</span><br><span class="line">...</span><br><span class="line">on boot //启动核心服务</span><br></pre></td></tr></table></figure><p>从 <code>init.rc</code> 文件可以看出该文件的解析是按照一定的顺序进行解析的。即以 <code>early-init &gt;&gt; init &gt;&gt; late-init</code> 的顺序进行解析。</p><h5 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h5><p><code>zygote</code> 服务被定义在 <code>init.zygote.rc</code> 文件中，与 <code>init.rc</code> 在相同的目录下，即 <code>system/core/rootdir</code> 目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br></pre></td></tr></table></figure><p>其中，会执行到 <code>zygote</code> 的源代码, 其源代码位于 <code>/framework/base/cmds/app_process/APP_main.cpp</code> 文件的 <code>main</code> 下，但在这里先不对其详细的逻辑进行展开。</p><h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><h5 id="1-0-restart-processes"><a href="#1-0-restart-processes" class="headerlink" title="# 1.0 restart_processes"></a># 1.0 restart_processes</h5><p>[-&gt;init.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart_processes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    process_needs_restart = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">service_for_each_flags</span>(SVC_RESTARTING,</span><br><span class="line">                           restart_service_if_needed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的作用是检查 <code>service_list</code> 中的所有服务，对带有 <code>SVC_RESTARTING</code> 标志的服务，则会去调用方法 <code>restart_service_if_needed</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart_service_if_needed</span><span class="params">(struct service *svc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> next_start_time = svc-&gt;time_started + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_start_time &lt;= <span class="built_in">gettime</span>()) &#123;</span><br><span class="line">        svc-&gt;flags &amp;= (~SVC_RESTARTING);</span><br><span class="line">        <span class="built_in">service_start</span>(svc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((next_start_time &lt; process_needs_restart) ||</span><br><span class="line">        (process_needs_restart == <span class="number">0</span>)) &#123;</span><br><span class="line">        process_needs_restart = next_start_time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会去调用 <code>service_start</code> 方法来启动服务。</p><h5 id="1-2-signal-handler-init"><a href="#1-2-signal-handler-init" class="headerlink" title="# 1.2 signal_handler_init"></a># 1.2 signal_handler_init</h5><p>在 <code>init</code> 进程的 <code>main</code> 方法中，通过调用 <code>signal_handler_init</code> 方法来初始化对 <code>signal</code> 信号的处理。其主要的处理逻辑有以下：</p><ul><li><code>sigaction</code> 动作注册需要监听的信号类型；</li><li>通过 <code>waitpid</code> 循环监听子进程的结束情况，存在子进程退出，便给退出的子进程标记上 <code>SVC_RESTARTING</code>;</li><li>通过 <code>epoll_ctl</code> 把需要监听的 <code>socket fd</code> 注册在 <code>epoll_fd</code> 上，当  <code>socket fd</code> 发生变化，便调用 <code>handle_signal</code> 处理子进程退出的情况；</li></ul><h5 id="1-2-1-signal-handler-init"><a href="#1-2-1-signal-handler-init" class="headerlink" title="# 1.2.1 signal_handler_init"></a># 1.2.1 signal_handler_init</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_handler_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 机制 ==》 mechanism</span></span><br><span class="line">    <span class="comment">// Create a signalling mechanism for SIGCHLD.</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 创建socket pair</span></span><br><span class="line"><span class="comment">// socketpair()函数用于创建一对无名的、相互连接的套接字；</span></span><br><span class="line"><span class="comment">// 如果函数成功，则返回0，创建好的套接字分别是sv[0]和sv[1]；否则返回-1，错误码保存于errno中；</span></span><br><span class="line"><span class="comment">// socketpair的用法和理解 ===》》 https://blog.csdn.net/weixin_40039738/article/details/81095013</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">socketpair</span>(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>, s) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">ERROR</span>(<span class="string">&quot;socketpair failed: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal_write_fd = s[<span class="number">0</span>];</span><br><span class="line">    signal_read_fd = s[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 当捕获信号SIGCHLD，则写入signal_write_fd</span></span><br><span class="line">    <span class="comment">// Write to signal_write_fd if we catch SIGCHLD.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(act));</span><br><span class="line"><span class="comment">// SA_NOCLDSTOP使init进程只有在其子进程终止时才会收到SIGCHLD信号</span></span><br><span class="line"><span class="comment">// 设置信号处理函数句柄,当有信号产生时,会向上面创建的socket写入数据,</span></span><br><span class="line"><span class="comment">// epoll监控到该socket对中的fd可读时,就会调用注册的函数去处理该事件；（写入数据）</span></span><br><span class="line">    act.sa_handler = SIGCHLD_handler;</span><br><span class="line"><span class="comment">// 设置标志,表示只有当子进程终止时才接受SIGCHID信号</span></span><br><span class="line">    act.sa_flags = SA_NOCLDSTOP; <span class="comment">//sa_nocldstop</span></span><br><span class="line"><span class="comment">// 注册监听 SIGCHLD 信号</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入waitpid来处理子进程是否退出的情况</span></span><br><span class="line">    <span class="built_in">reap_any_outstanding_children</span>();</span><br><span class="line"><span class="comment">// （读取数据）==&gt; 当 signal_read_fd 有数据来的时候，会调用 handle_signal 函数进行</span></span><br><span class="line">    <span class="built_in">register_epoll_handler</span>(signal_read_fd, handle_signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化两个 <code>signal_write_fd</code>、以及 <code>signal_read_fd</code> 读写端，作用于当系统发出指定的 <code>SIGCHLD</code> 信号时，通知执行 <code>handle_signal</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clear outstanding requests.</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="comment">// 读取  signal_read_fd 中的数据，并放入 buf 中；</span></span><br><span class="line">    <span class="built_in">read</span>(signal_read_fd, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">    <span class="built_in">reap_any_outstanding_children</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 <code>handle_signal</code> 中，会去调用到 <code>reap_any_outstanding_children</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reap_any_outstanding_children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">wait_for_one_process</span>()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>reap_any_outstanding_children</code> 中，如果 <code>wait_for_one_process</code> 在返回 <code>false</code> 的情况下，会一直循环，通过 <code>wait_for_one_process</code> 里面的 <code>waitpid</code> 来等待可能的子进程退出的情况。当监听到子进程存在退出的情况，那么最后会给该子进程打上 <code>SVC_RESTARTING</code> 的标记。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <code>init</code> 进程(pid=1)是 Linux 系统中用户空间的第一个进程，主要的工作如下：</p><ul><li>初始化属性服务；</li><li>解析各个 rc 文件，并启动相应的服务进程；</li><li>初始化 epoll，依次执行 signal 等回调函数；</li><li>进入无限循环状态，主要做如下工作：<ul><li>检查 service_list 中的所有服务，对于带有 SVC_RESTARTING 标志的服务，则都会调用其相应的restart_service_if_needed；（检查是否有需要重启的进程）</li><li>进入 epoll_wait 状态，直到系统属性发生变化，或者有 keychord 键盘输入事件，则会等待状态，执行相应的回调函数；</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基于 Android 6.0.0 源码进行分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 进程涉及的源码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/system/core/init/init.cpp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 进程是 Linux 系统中用户空间的第一个进程，其进程号为 1。在 &lt;code&gt;Kernel&lt;/code&gt; 启动后，在用户空间启动 &lt;code&gt;init&lt;/code&gt; 进程，并调用 &lt;code&gt;init&lt;/code&gt; 中的 &lt;code&gt;main()&lt;/code&gt; 方法执行 &lt;code&gt;init&lt;/code&gt; 进程的职责。对于 &lt;code&gt;init&lt;/code&gt; 进程的功能，通过分析其 &lt;code&gt;main()&lt;/code&gt; 方法的逻辑，主要可以划分为以下 5 部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;挂载、创建所系统运行所需要的目录，如 &lt;code&gt;tmpfs&lt;/code&gt;、&lt;code&gt;pts&lt;/code&gt;、&lt;code&gt;proc&lt;/code&gt;…&lt;/li&gt;
&lt;li&gt;加载属性服务；&lt;/li&gt;
&lt;li&gt;解析并运行所有的 init.rc 相关的文件；&lt;/li&gt;
&lt;li&gt;化身为守护进程，处理signal、property和keychord等服务；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Framework" scheme="https://hndroid.github.io/categories/Framework/"/>
    
    
    <category term="Android" scheme="https://hndroid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2源码分析</title>
    <link href="https://hndroid.github.io/2020/06/06/Retrofit2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://hndroid.github.io/2020/06/06/Retrofit2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-06-06T09:31:00.000Z</published>
    <updated>2021-06-20T11:52:16.131Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://baihonghua.cn/Snipaste_2020-06-05_21-35-37.png"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>相信使用过 Retrofit2 网络请求库的童鞋都会对上面的图片有一种熟悉的感觉。是的，上面的图片便是来源自 <a href="https://square.github.io/retrofit/">Retrofit</a> 的官网的截图。官网上使用了一句话对 Retrofit 进行了扼要的介绍： <em><strong>A type-safe HTTP client for Android and Java</strong></em>，我对这句话的理解是：Retrofit 是一个可以使用在 Android 和 Java 上面的 <em><strong>类型安全的 HTTP 客户端</strong></em>。为什么说 Retrofit 是一个类型安全的的 HTTP 客户端呢？我会在文中提及、以及文后小结出来的。</p><span id="more"></span><h4 id="网络请求的一般步骤"><a href="#网络请求的一般步骤" class="headerlink" title="网络请求的一般步骤"></a>网络请求的一般步骤</h4><p><img src="http://baihonghua.cn/Snipaste_2020-06-05_22-26.png"></p><p>上图是利用 Retrofit 在 Android 实现的一般网络请求的步骤，执行的结果是返回 Github 上的 <em><strong>octocat</strong></em> 用户的仓库列表。以下是对上图的解析说明：</p><ul><li><p>标注 1 处的 <code>GitHubService</code> 接口主要是为了声明 API 方法， API 方法必须需要声明在接口里面、该接口不可以带有类型参数、而且该接口不可以继承其他的接口，如果不遵守以上约定，代码在运行期间都会抛出异常的。同时，如果该接口定义了 JDK8 及以上支持的 <code>default</code> 方法、静态方法，这些新特性的方法是不被执行的。<em><strong>在这里，通过对 <code>GitHubService</code> API 接口、以及 API 方法的验证，保证了在进行网络请求前的类型安全。</strong></em></p></li><li><p>标注 2 处是通过一个典型的构建者模式构建出一个 <code>Retrofit</code> 对象，在构建对象的过程中，根据项目的需要，可以通过 <code>Retrofit#addConverterFactory()</code> 方法和 <code>Retrofit#addCallAdapterFactory()</code> 方法等构建出特性差异的 <code>Retrofit</code> 对象，这也是把构建者模式的好处淋漓尽致地表现了出来。至于以上两个方法具体的作用，我会在下文具体描述。</p></li><li><p>标注 3 处是把接口 <code>GitHubService</code> 通过 <code>Retrofit#create()</code> 方法，内部通过动态代理模式，利用字节码技术在内存里面生成一个 <code>GitHubService</code> 的代理对象，通过代理对象去调用 API 方法，然后底层通过反射调用执行真正的 API 方法，达到在程序运行期间，根据接口模板的不同，动态地生成对应的代理对象，去执行 API 方法。这里也是非常好地诠释了动态代理模式的作用。</p></li><li><p>标注 4 处是通过一个 <code>Call</code> 接口的实现，去调用 <code>Call&lt;T&gt;#enqueue()</code> 方法。<code>Call&lt;T&gt;enqueue()</code> 是一个异步地处理网络请求，并通过接口回调 <code>Callback</code> 返回请求的响应体，或者发生的错误等信息。同时，还可以通过 <code>Call&lt;T&gt;#execute()</code> 同步地发送请求和返回响应体。</p></li></ul><h4 id="网络请求的流程分析"><a href="#网络请求的流程分析" class="headerlink" title="网络请求的流程分析"></a>网络请求的流程分析</h4><p>这里的网络请求的流程分析，我会仍然围绕上图进行展开。一般来说，阅读源码的时候，带着问题去驱动阅读，会比较容易弄明白源码的逻辑，不容易迷失在代码的细节里面。</p><p>那么，首先抛出的问题：<em><strong>上图中，代码标注 3 执行到标注 4 的过程，代码经历了那些操作呢？</strong></em></p><ul><li><h6 id="Retrofit-create"><a href="#Retrofit-create" class="headerlink" title="Retrofit#create()"></a>Retrofit#create()</h6></li></ul><p><img src="http://baihonghua.cn/20200606113938.png"></p><p>我们通过阅读 <code>Retrofit#create()</code> 源码，发现其内部主要是做了对 API 接口的验证、以及使用动态代理，根据验证后的 API 接口生成返回接口的实现对象，这里生成的 <code>GitHubService</code> 代理对象名字一般为 <code>$Proxy0</code>。这里呢，我就不继续展开对动态代理的详细描述了，如果你阅读到这里发现自己不太理解动态代理模式的话，可以去看看我写的 <a href="https://hndroid.github.io/2020/03/19/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">动态代理原理分析</a> 一文，或者在网络上搜索其他描述动态代理的文章。</p><p>在标注 2 处主要的逻辑是做 Java 版本的验证，以及不同版本的 Java 版本执行不同的方法，这主要是为了兼容不同的版本平台。</p><ul><li><h5 id="Retrofit-loadServiceMethod"><a href="#Retrofit-loadServiceMethod" class="headerlink" title="Retrofit#loadServiceMethod()"></a>Retrofit#loadServiceMethod()</h5></li></ul><p><img src="http://baihonghua.cn/20200606131524.png"></p><p>在上图中，<code>Retrofit#loadServiceMethod()</code> 方法主要是检查缓存 <code>serviceMethodCache</code> 里面是否已经存在需要被执行的 API 方法，如果存在则直接返回，如果不存在则通过执行 标注2 处的方法进行解析返回 API 方法。为什么需要这个检查缓存的功能呢？因为在解析 API 的过程中，我们通过查看 标注2 处的方法，来到 <code>ServiceMethod&lt;T&gt;#RequestFactory.parseAnnotations()</code> 的方法处，那么我们通过阅读 标注3 处代码如下图过程：</p><p><img src="http://baihonghua.cn/20200606132137.png"></p><p>如上图，最终我们来到 标注1 处，发现解析 API 方法需要解析方法的注解、解析方法的泛型的类型参数、以及解析方法参数的注解，这些在代码里面都会是比较耗时的操作，而在移动端的网络请求的过程中，过多执行耗时的操作，显然是不被我们所接受的，我们都希望网络请求的结果可以更快地呈现在我们的手机屏幕上。因而，便有了以上的读取缓存的操作。</p><ul><li><h5 id="ServiceMethod-HttpServiceMethod-parseAnnotations"><a href="#ServiceMethod-HttpServiceMethod-parseAnnotations" class="headerlink" title="ServiceMethod#HttpServiceMethod.parseAnnotations()"></a>ServiceMethod<T>#HttpServiceMethod.parseAnnotations()</T></h5></li></ul><p>我们回到上图 标注4 处，这里继续对 API 方法进行解析。我们都知道，对注解进行解析，往往会使用到反射，正如该方法的官方注释写道： <em><strong>This requires potentially-expensive reflection so it is best to build each service method only once and reuse it.</strong></em> 这同时也验证了上文读取缓存的必要性。</p><p><img src="http://baihonghua.cn/20200606143045.png"></p><p>上图中的方法主要有三处，我分别给标注了出来。其他省略的部分主要是对 API 方法类型的检查，使得请求网络的时候类型是安全的。</p><ul><li><p>标注 1 处主要是与上文提及的 <code>Retrofit#addCallAdapterFactory()</code> 方法相关，默认地，如果我们不手动调用该方法，那么 <code>Retrofit</code> 也会手动添加一个 <code>DefaultCallAdapterFactory</code> 对象, 如果是 JDK8 的平台，还会默认添加一个 <code>CompletableFutureCallAdapterFactory</code> 对象。<code>CallAdapter</code> 在 <code>Retrofit</code> 的作用主要是什么呢？<br>简单来说，就是把网络请求返回来的响应体，包装一层形成新的返回对象。如在接口 API 方法里面，原本默认返回的是 <code>Call&lt;ResponseBody&gt;</code>，如果调用 <code>Retrofit#addCallAdapterFactory()</code> 方法，添加对 RxJava 的支持，如添加 <code>RxJava2CallAdapterFactory.create()</code>, 那么在接口 API 方法可以返回的是 <code>Observable&lt;ResponseBody&gt;</code>。</p><p>  <img src="http://baihonghua.cn/20200606152018.png"></p></li><li><p>标注 2 处则是直接把请求体或相应体转换成需要的格式。</p></li></ul><p>最终，我们来到标注 3 处，这里是上文 <code>Retrofit#loadServiceMethod()</code> 调用之后返回 <code>CallAdapted</code> 的对象：</p><p><img src="http://baihonghua.cn/20200606154500.png"></p><p>这时，便会调用 <code>ServiceMethod&lt;T&gt;#invoke()</code> 方法，通过阅读源码，我们得知，<code>CallAdapted</code> 是继承自 <code>HttpServiceMethod&lt;ResponseT, ReturnT&gt;</code> 类，而 <code>HttpServiceMethod&lt;ResponseT, ReturnT&gt;</code> 类又继承自 <code>ServiceMethod&lt;ReturnT&gt;</code> 类，那么这里调用实际是 <code>CallAdapted</code> 的对象。我们可以通过找到 <code>CallAdapted</code> 类阅读发现，<code>incoke()</code> 方法最终是调用了 <code>CallAdapted</code> 类里面的 <code>CallAdapted#adapt()</code>:</p><p><img src="http://baihonghua.cn/20200606155934.png"></p><p>经过阅读代码，我们最终来到了 标注1 处的代码，并且发现，此时的 <code>callAdapter.adapt(call)</code> 中的 <code>callAdapter</code> 就是上文提到的 <code>Retrofit#addCallAdapterFactory()</code> 中的 <code>Adapter</code>。假设我们在构建 Retrofit 的时候，没有调用该方法，那么 Retrofit 就会默认地调用到 <code>DefaultCallAdapterFactory</code> 类中的 <code>DefaultCallAdapterFactory#adapt()</code>:</p><p><img src="http://baihonghua.cn/20200606161331.png"></p><p>当 <em><strong>Retrofit#create()</strong></em> 执行完，并且调用 API 方法之后，返回了一个 <code>ExecutorCallbackCall</code> 对象。通过执行<code>ExecutorCallbackCall#enqueue()</code> 去调用真正进行网络请求的 <code>OkHttpCall#enqueue()</code> 方法。在这里源码里面，还使用到了一个设计模式：适配器模式。</p><p>适配器模式可以细分为两种：类适配器和对象适配器</p><ul><li><p>类适配器使用继承关系来实现；</p></li><li><p>对象适配器使用组合来实现；</p></li></ul><p>通过分析源码，可以发现，<code>CallAdapted</code> 采用的适配器模式是对象适配器的。到此，就完整地回答了在文章开头提出的： <em><strong>代码标注 3 执行到标注 4 的过程，代码经历了那些操作呢？</strong></em> 。总结来说，<code>Retrofit</code> 通过构建者模式构造出其实例，在构建的过程中，根据项目的需要，可以添加响应体适配器、以及请求和返回内容的转换器等，然后通过动态代理生成代理对象，去调用 API 接口方法，通过同步或异步返回响应体。</p><p>下图是 Retrofit 进行网络请求的时序图：</p><p><img src="http://baihonghua.cn/20200606170356.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在上文，还有一个问题 <em><strong>为什么说 Retrofit 是一个类型安全的的 HTTP 客户端呢？</strong></em> 在对 <code>Retrofit</code> 源码的分析的过程中，我们会发现 <code>Retrofit</code> 会对 API 接口、以及 API 接口方法进行严格的检查，从而避免了 <code>Retrofit</code> 在网络请求的过程中，会发生 API 接口、接口方法类型错误的问题。</p><blockquote><p>在文末，如果你可以看到这段话，超级感谢你可以耐心阅读完整一篇文章。首先，为了写这一篇文章，我从阅读 Retrofit 的源码，到写出这边文章，花了整整一周的时间。因为我觉得，既然要把文章写出来，就不可以随随便便去应付去写。在写文章的同时，需要确保自己写的东西的准确性，不可以写出来误导了别人。写作是一种能力，同时写出的文章让别人看得懂，那就是另外一种更高层次的能力了。在这里我希望，你可以读完我的文章后，可以去验证我文章的观点，因为我觉得，无论谁提出的观点，都需要自己带有一种批判的思维去看待。只有经历的起自己的推敲的观点，才是真真正正正确的。</p><p>同时，我希望如果你发现我写的文章中存在不足或错误的地方，希望你可以指出，我真的会很感激你的帮助的。毕竟，如果一个人连错误都不敢承担，那么他该如何成长呢？</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://baihonghua.cn/Snipaste_2020-06-05_21-35-37.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;相信使用过 Retrofit2 网络请求库的童鞋都会对上面的图片有一种熟悉的感觉。是的，上面的图片便是来源自 &lt;a href=&quot;https://square.github.io/retrofit/&quot;&gt;Retrofit&lt;/a&gt; 的官网的截图。官网上使用了一句话对 Retrofit 进行了扼要的介绍： &lt;em&gt;&lt;strong&gt;A type-safe HTTP client for Android and Java&lt;/strong&gt;&lt;/em&gt;，我对这句话的理解是：Retrofit 是一个可以使用在 Android 和 Java 上面的 &lt;em&gt;&lt;strong&gt;类型安全的 HTTP 客户端&lt;/strong&gt;&lt;/em&gt;。为什么说 Retrofit 是一个类型安全的的 HTTP 客户端呢？我会在文中提及、以及文后小结出来的。&lt;/p&gt;</summary>
    
    
    
    <category term="Android开源库" scheme="https://hndroid.github.io/categories/Android%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="Retrofit" scheme="https://hndroid.github.io/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>AIDL机制</title>
    <link href="https://hndroid.github.io/2020/04/21/AIDL%E6%9C%BA%E5%88%B6/"/>
    <id>https://hndroid.github.io/2020/04/21/AIDL%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-21T04:59:44.000Z</published>
    <updated>2021-06-20T11:52:16.126Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前一段时间，除了忙在公司项目的重构和优化，然后就主要把时间花在 Java 的一些基础进行回顾。按照我的计划，接下来的一段时间里面，我会把时间主要花在 Android 的 Framework 层，当然也计划了 Kotlin 的协程呀、Jetpack 组件呀这些的深入理解….</p><span id="more"></span><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="# 目录结构"></a># 目录结构</h5><p><img src="http://baihonghua.cn/20200420171137.png"></p><h5 id="AIDL"><a href="#AIDL" class="headerlink" title="# AIDL"></a># AIDL</h5><p>IMyAidlInterface.aidl 文件内容：</p><p><img src="http://baihonghua.cn/20200420171411.png"></p><p>Word.aidl 文件内容：</p><p><img src="http://baihonghua.cn/20200420171323.png"></p><p>Word.java 文件内容：</p><p><img src="http://baihonghua.cn/20200420171544.png"></p><p>其中，在 <code>IMyAidlInterface.aidl</code> 文件中，允许通过一个或多个方法来声明接口：</p><ul><li><p>AIDL 默认支持 Java 的八种基本类型；</p></li><li><p>AIDL 还支持 <code>String</code>、<code>CharSequence</code>、<code>List</code>、<code>Map</code> 类型，但在 <code>List</code>、<code>Map</code> 中的元素必须是八种基本类型、或 AIDL 生成的接口、或 <code>Parcelable</code> 类型；</p></li><li><p>List 支持泛型，而 Map 不支持泛型；</p></li><li><p>如果 AIDL 使用到自定义的 <code>Parcelable</code> 对象，那么需要新建一个和需要使用到的 AIDL 文件同名、并位于同一个包内，同时需要通过 <code>import</code> 关键字导入到需要使用的 AIDL 文件中；</p></li><li><p>AIDL 除了使用到的基本类型，其他类型都需要标上方向：<code>in</code>、<code>out</code>、<code>inout</code>；</p></li></ul><p>新建好上面的三个文件，随后通过 Android Studio 可以编译生成一个 <code>IMyAidlInterface.java</code> 文件（文件里面的内容过多，我在这里就不详细引入了）。然后依次编写 AIDL 的 Client 端和 Server 端，如下：</p><p>AIDLService.java</p><p><img src="http://baihonghua.cn/20200420182524.png"></p><p>AndroidManifest.xml</p><p><img src="http://baihonghua.cn/20200420182617.png"></p><p>MainActivity.java</p><p><img src="http://baihonghua.cn/20200420182817.png"></p><p>在 <code>MainActivity</code> 和 <code>AIDLService</code> 中编写的代码都是拿到 Binder 引用，进行 IPC 的跨进程通信。其中在 <code>AIDLService</code> 中，是通过：</p><p><img src="http://baihonghua.cn/20200420183442.png"></p><p><code>new IWordManager.Stub()</code> 的创建对象的方式，拿到 <code>Binder</code> 引用，然后把该引用通过 <code>onBind()</code> 方法返回。其中，<code>Stub</code> 是一个接口，并且继承 <code>android.os.Binder</code> 和实现 <code>com.example.aidl.IWordManager</code>, 然后把该 Binder 对象（也可以看作 <code>IWordManager</code>）的引用传到 <code>Client</code> 端，即 <code>MainActivity</code> ：</p><p><img src="http://baihonghua.cn/20200420185619.png"></p><p>上面的 <code>val iWordManager = IWordManager.Stub.asInterface(service)</code> 拿到了 <code>Server</code> 端传过来的 <code>Binder</code> 对象，然后转换成 <code>IWordManager</code>, 最后在 <code>AIDLService</code> 和 <code>MainActivity</code> 都持有了 <code>IWordManager</code> 的引用，也就意味着可以调用 <code>IWordManager</code> 里面的方法。</p><p>为什么会在 <code>AIDLService</code> 和 <code>MainActivity</code> 都可以看作持有 <code>IWordManager</code> 的引用呢，因为 AIDL 也是一个 C/S 模型的通信模式，<code>Client</code> 端和 <code>Server</code> 端都是相对而言的。在 <code>AIDLService</code> 请求 <code>MainActivity</code> 的内容的时候，<code>AIDLService</code> 可以看作 <code>Server</code> 端,当 <code>MainActivity</code> 接收 <code>MainActivity</code> 内容的时候，<code>AIDLService</code> 可以看作 <code>Client</code> 端。</p><p>那么在 <code>AIDLService</code> 中是如何把 <code>IWordManager</code> 对象（也就是 Binder）引用传到 <code>MainActivity</code> 中的呢？我们可以通过分析源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AIDLService.java</span></span><br><span class="line"><span class="keyword">private</span> Binder mBind = <span class="keyword">new</span> IWordManager.Stub() &#123;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Word&gt; <span class="title">getWord</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mWordList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(Word word)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;AIDLService ---- &gt;&gt; addWord: &quot;</span> + word.somethingWord);</span><br><span class="line">        mWordList.add(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们通过查看注释 1 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IWordManager 源码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">aidl</span>.<span class="title">IWordManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">&quot;com.example.aidl.IWordManager&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于把 Binder 对象转换成 IWordManager 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.example.aidl.<span class="function">IWordManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 查询进程本地是否存在 IWordManager 对象，存在则直接返回</span></span><br><span class="line">        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.aidl.IWordManager))) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((com.example.aidl.IWordManager) iin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过跨进程获取 IWordManager 对象， 通过查看下面的注释 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> com.example.aidl.IWordManager.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// Proxy 是被另外的一个进程的 IWordManager 所初始化，所以返回的是另外一个进程的 IWordManager 引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">aidl</span>.<span class="title">IWordManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">        Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">            mRemote = remote;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mRemote;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> java.util.List&lt;com.example.aidl.Word&gt; getWord() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">            <span class="comment">// 需要发送的数据 _data （android.os.Parcel 对象可以通过 Binder 发送）</span></span><br><span class="line">            android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">            <span class="comment">// 接收的数据 _reply</span></span><br><span class="line">            android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">            java.util.List&lt;com.example.aidl.Word&gt; _result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                <span class="comment">// 成功返回 true，失败返回 false</span></span><br><span class="line">                <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getWord, _data, _reply, <span class="number">0</span>);  <span class="comment">// 3</span></span><br><span class="line">                <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> getDefaultImpl().getWord();</span><br><span class="line">                &#125;</span><br><span class="line">                _reply.readException();</span><br><span class="line">                <span class="comment">// 通过调用 android.os.Parcel#createTypedArrayList() 方法，读取 _reply 里面的数据</span></span><br><span class="line">                _result = _reply.createTypedArrayList(com.example.aidl.Word.CREATOR);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                _reply.recycle();</span><br><span class="line">                _data.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(com.example.aidl.Word word)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">            android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                <span class="keyword">if</span> ((word != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                    word.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_addWord, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    getDefaultImpl().addWord(word);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                _reply.readException();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getWord = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addWord = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在继续往下阅读源码的时候，需要明白以下几个知识点，不然容易会看得云里雾里：</p><ul><li><p>关于 <code>_data</code>、<code>_reply</code> 两个 <code>android.os.Parcel</code> 对象, <code>_data</code> 主要是用来存放 <code>Client</code> 端需要发送的数据，而 <code>_reply</code> 主要是用来存放用来接收的数据。对于 <code>android.os.Parcel</code> 是一个可以通过 <code>Binder</code> 传输的数据结构，简单来说，<code>Binder</code> 之间的通信交流数据是以 <code>android.os.Parcel</code> 作为载体，而数据通过序列化后存在载体 <code>android.os.Parcel</code> 上（这里需要注意的是，<code>parcel</code> 和 <code>Parcelable</code> 是两个不同的概念，而 <code>Parcelable</code> 和 <code>Serializable</code> 是两个类似的概念）。</p></li><li><p><code>Binder#transact()</code> 是客户端和服务端的核心方法，通过调用该方法，客户端会暂时挂起，等待服务端的数据写入 <code>_reply</code> 返回，对于 <code>Binder#transact()</code> 的四个方法参数（code、data、reply、flags）需要以下的几点说明：</p><ul><li><p><strong>code</strong> 指的是代表 AIDL 接口文件中定义的方法的 ID，因为在客户端和服务端中的 AIDL 文件中，定义了一一对应的方法。因而在 AIDL 文件转成 <code>.java</code> 文件的时候，系统会为每个方法生成对应的 ID，通过阅读源码，可以知道方法的 ID 是从 1 开始的；</p></li><li><p><strong>data</strong>、<strong>reply</strong> 对应上文的 <code>_data</code> 和 <code>_reply</code>;</p></li><li><p>第四个参数 <strong>flags</strong> 当为 0 的时候，表示全双工的 RPC 机制，也就是 <strong>data</strong> 发送数据，而 <strong>reply</strong> 接收数据；当为 1 的时候，表示半双工的 RPC 机制，也就是 <strong>data</strong> 发送数据，而 <strong>reply</strong> 是没有数据的。</p></li></ul></li></ul><p>通过阅读 <code>IWordManager.java#Proxy</code> 源码，我们发现, AIDL 是通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getWord, _data, _reply, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_addWord, _data, _reply, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>到此，我们可以得出结论：</p><ul><li><p>在 <code>_data</code> 中存入客户端需要发送的数据；</p></li><li><p>通过 <code>mRemote#transact()</code> 把 <code>_data</code> 传给服务端；</p></li><li><p>通过接收 <code>_reply</code> 接收数据，从中取出服务端发送过来的数据；</p></li></ul><p>上述两个语句通过 mRemote 去发起调用 transact() 方法的，同时我们通过查看代码，知道 <code>mRemote</code> 就是 Binder 对象。通过继续阅读 <code>Binder#transact()</code> 方法，可以发现其最终是调用 <code>Binder#onTransact(int, Parcel, Parcel,int)</code> 方法，因为在 <code>IWordManager#Stub</code> 是继续了 <code>Binder</code>, 以此调用的是 <code>Stub#onTransact()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// getWord()</span></span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getWord: &#123;</span><br><span class="line">           ....</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// addWord()</span></span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addWord: &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以看出，当接收到 <code>onTransact()</code> 的调用后，直接来个 <code>swith</code> 语句进行 <code>case</code>，这里我以 <code>getWord()</code> 方法为例，分析 <code>_reply</code> 是如何从中拿出服务端的数据的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">           ....</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                ....</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getWord: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    <span class="comment">// _result 为 getWord() 的返回值</span></span><br><span class="line">                    java.util.List&lt;com.example.aidl.Word&gt; _result = <span class="keyword">this</span>.getWord();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="comment">// 从 reply 中取出数据写入 _result 中</span></span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以发现，在 <code>Proxy#transact()</code> 发起调用时候，在 <code>Stub#onTransact()</code> 中响应调用，看起来好像就是在本地 <code>Proxy#transact()</code> “直接”调用了 <code>Stub#onTransact()</code>。其实这个 “直接” 的过程是 Binder 为我们封装了细节，让我们感受不到其中的通信的曲折，我想这也是 Binder 跨进程通信最初设计的目的吧。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在我们已经完成了 Wordmanager.java 的分析，下面我附上两张图片来做一个小总结：</p><p><img src="http://baihonghua.cn/20200421114400.png"></p><p><img src="http://baihonghua.cn/20200421115326.png"></p><p>这篇分析 AIDL 机制是基于 Binder 的应用层面的分析，如果我们需要深入了解 Binder 的跨进程原理，我们仍然需要深入到 Binder 的 Framework 层和 Native 层等进行源码的分析。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;前一段时间，除了忙在公司项目的重构和优化，然后就主要把时间花在 Java 的一些基础进行回顾。按照我的计划，接下来的一段时间里面，我会把时间主要花在 Android 的 Framework 层，当然也计划了 Kotlin 的协程呀、Jetpack 组件呀这些的深入理解….&lt;/p&gt;</summary>
    
    
    
    <category term="Android进阶" scheme="https://hndroid.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Android" scheme="https://hndroid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊JavaPoet技术</title>
    <link href="https://hndroid.github.io/2020/04/10/%E8%81%8A%E4%B8%80%E8%81%8AJavaPoet%E6%8A%80%E6%9C%AF/"/>
    <id>https://hndroid.github.io/2020/04/10/%E8%81%8A%E4%B8%80%E8%81%8AJavaPoet%E6%8A%80%E6%9C%AF/</id>
    <published>2020-04-10T03:33:09.000Z</published>
    <updated>2021-06-20T11:52:16.148Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p><a href="https://github.com/square/javapoet">JavaPoet</a> is a Java API for generating .java source files.</p></blockquote><span id="more"></span><p><code>JavaPoet</code> 是一个用于生成 <code>.java</code> 源文件的 <code>Java API</code>, 在许多如 <code>ButterKnift</code>、<code>ARoute</code> 等使用了 APT 技术的开源库中，都可以看到 <code>JavaPoet</code> 的影子。在解析注解生成 Java 源文件的过程中，<code>JavaPoet</code> 起的作用很大。</p><p><img src="http://baihonghua.cn/JavaPoet%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"></p><p>上图是 <code>JavaPoet</code> 库的文件结构：</p><ul><li><p><code>AnnotationSpec</code> 用于生成注解相关的 API；</p></li><li><p><code>FieldSpec</code> 用于生成属性变量字段相关的 API；</p></li><li><p><code>MethodSpec</code> 用于生成类的构造器、或者方法相关的 API；</p></li><li><p><code>ParameterSpec</code> 用于生成方法参数相关的 API；</p></li><li><p><code>TypeSpec</code> 用于生成 <code>class</code> 类、接口、或者 <code>enum</code> 相关的 API；</p></li><li><p><code>className</code> 用于声明在 <code>.java</code> 文件中通过 <code>import</code> 关键字导入</p></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>在 Android Studio 中新建一个 Java 库，然后在 <code>.gradle</code> 文件中添加 <code>JavaPoet</code> 的依赖，效果如下：</p><p><img src="http://baihonghua.cn/JavaPoet%E4%BE%9D%E8%B5%96%E5%BA%93.png"></p><p>在了解 <code>JavaPoet</code> 生成 <code>.java</code> 文件的规则之前，有必要先了解 <code>JavaPoet</code> 的字符串格式化规则:</p><table><thead><tr><th align="center">符号</th><th align="left">意义</th></tr></thead><tbody><tr><td align="center"><code>$L</code></td><td align="left">表示字面量，如: <code>int value = $L</code></td></tr><tr><td align="center"><code>$S</code></td><td align="left">表示字符串</td></tr><tr><td align="center"><code>$T</code></td><td align="left">可以表示类、接口</td></tr><tr><td align="center"><code>$N</code></td><td align="left">表示变量、函数名，和 <code>$S</code> 区分，主要是 <code>$N</code> 有实际的意义</td></tr></tbody></table><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="# 例子_1"></a># 例子_1</h5><p>如下，如果我们知道我们要生成的类格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.String;</span><br><span class="line"><span class="keyword">import</span> java.lang.System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, JavaPoet!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>JavaPoet</code> 库，我们可以通过如下 API ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 main 方法</span></span><br><span class="line">MethodSpec mainMethod = MethodSpec.methodBuilder(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">        .addParameter(String[].class, <span class="string">&quot;args&quot;</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">        .addStatement(<span class="string">&quot;$T.out.println($S)&quot;</span>, System.class, <span class="string">&quot;Hello, JavaPoet!&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 HelloWorld 类</span></span><br><span class="line">TypeSpec helloWorldClass = TypeSpec.classBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">        .addMethod(mainMethod)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 .java 文件</span></span><br><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">&quot;com.example.helloworld&quot;</span>, helloWorldClass)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 把生成的 .class 文件内容写出到标准控制台</span></span><br><span class="line">    javaFile.writeTo(System.out);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://baihonghua.cn/JavaPoet-HelloWorld.png"></p><h5 id="例子-2"><a href="#例子-2" class="headerlink" title="# 例子_2"></a># 例子_2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (System.currentTimeMillis() &lt; now) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Time travelling, woo hoo!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.currentTimeMillis() == now) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Time stood still!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Ok, time still moving forward&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过 <code>JavaPoet</code> 生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec mainMethod = MethodSpec.methodBuilder(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">                .addStatement(<span class="string">&quot;long now = $T.currentTimeMillis()&quot;</span>, System.class)</span><br><span class="line">                .beginControlFlow(<span class="string">&quot;if ($T.currentTimeMillis() &lt; now)&quot;</span>, System.class)</span><br><span class="line">                .addStatement(<span class="string">&quot;$T.out.println($S)&quot;</span>, System.class, <span class="string">&quot;Time travelling, woo hoo!&quot;</span>)</span><br><span class="line">                .nextControlFlow(<span class="string">&quot;else if ($T.currentTimeMillis() == now)&quot;</span>, System.class)</span><br><span class="line">                .addStatement(<span class="string">&quot;$T.out.println($S)&quot;</span>, System.class, <span class="string">&quot;Time stood still!&quot;</span>)</span><br><span class="line">                .nextControlFlow(<span class="string">&quot;else&quot;</span>)</span><br><span class="line">                .addStatement(<span class="string">&quot;$T.out.println($S)&quot;</span>, System.class, <span class="string">&quot;Ok, time still moving forward&quot;</span>)</span><br><span class="line">                .endControlFlow()</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><p>对于上面的 <code>beginControlFlow()</code>、<code>nextControlFlow()</code>、<code>endControlFlow()</code>, 一般可以用在循环、异常捕获、条件判断等。注意，在循环、异常捕获、条件判断的花括号最后要加上 <code>endControlFlow()</code>。</p><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="# 例子_3"></a># 例子_3</h5><p>ClassName类型它可以标识任何声明的类。声明的类型只是Java丰富类型系统的开始：我们还具有数组，参数化类型，通配符类型和类型变量。JavaPoet具有用于构建以下每个类的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ClassName hoverboard = ClassName.get(<span class="string">&quot;com.mattel&quot;</span>, <span class="string">&quot;Hoverboard&quot;</span>);</span><br><span class="line">ClassName list = ClassName.get(<span class="string">&quot;java.util&quot;</span>, <span class="string">&quot;List&quot;</span>);</span><br><span class="line">ClassName arrayList = ClassName.get(<span class="string">&quot;java.util&quot;</span>, <span class="string">&quot;ArrayList&quot;</span>);</span><br><span class="line">TypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);</span><br><span class="line"></span><br><span class="line">MethodSpec beyond = MethodSpec.methodBuilder(<span class="string">&quot;beyond&quot;</span>)</span><br><span class="line">    .returns(listOfHoverboards)</span><br><span class="line">    .addStatement(<span class="string">&quot;$T result = new $T&lt;&gt;()&quot;</span>, listOfHoverboards, arrayList)</span><br><span class="line">    .addStatement(<span class="string">&quot;result.add(new $T())&quot;</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">&quot;result.add(new $T())&quot;</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">&quot;result.add(new $T())&quot;</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">&quot;return result&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的 <code>.java</code> 文件如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mattel.Hoverboard;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Hoverboard&gt; <span class="title">beyond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Hoverboard&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    result.add(<span class="keyword">new</span> Hoverboard());</span><br><span class="line">    result.add(<span class="keyword">new</span> Hoverboard());</span><br><span class="line">    result.add(<span class="keyword">new</span> Hoverboard());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="# 例子_4"></a># 例子_4</h5><p>JavaPoet支持导入静态。它通过显式收集类型成员名称来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ClassName namedBoards = ClassName.get(<span class="string">&quot;com.mattel&quot;</span>, <span class="string">&quot;Hoverboard&quot;</span>, <span class="string">&quot;Boards&quot;</span>);</span><br><span class="line"></span><br><span class="line">MethodSpec beyond = MethodSpec.methodBuilder(<span class="string">&quot;beyond&quot;</span>)</span><br><span class="line">    .returns(listOfHoverboards)</span><br><span class="line">    .addStatement(<span class="string">&quot;$T result = new $T&lt;&gt;()&quot;</span>, listOfHoverboards, arrayList)</span><br><span class="line">    .addStatement(<span class="string">&quot;result.add($T.createNimbus(2000))&quot;</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">&quot;result.add($T.createNimbus(\&quot;2001\&quot;))&quot;</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">&quot;result.add($T.createNimbus($T.THUNDERBOLT))&quot;</span>, hoverboard, namedBoards)</span><br><span class="line">    .addStatement(<span class="string">&quot;$T.sort(result)&quot;</span>, Collections.class)</span><br><span class="line">    .addStatement(<span class="string">&quot;return result.isEmpty() ? $T.emptyList() : result&quot;</span>, Collections.class)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec hello = TypeSpec.classBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addMethod(beyond)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile.builder(<span class="string">&quot;com.example.helloworld&quot;</span>, hello)</span><br><span class="line">    .addStaticImport(hoverboard, <span class="string">&quot;createNimbus&quot;</span>)</span><br><span class="line">    .addStaticImport(namedBoards, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">    .addStaticImport(Collections.class, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的 <code>.java</code> 文件如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.mattel.Hoverboard.Boards.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.mattel.Hoverboard.createNimbus;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Collections.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mattel.Hoverboard;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Hoverboard&gt; <span class="title">beyond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Hoverboard&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    result.add(createNimbus(<span class="number">2000</span>));</span><br><span class="line">    result.add(createNimbus(<span class="string">&quot;2001&quot;</span>));</span><br><span class="line">    result.add(createNimbus(THUNDERBOLT));</span><br><span class="line">    sort(result);</span><br><span class="line">    <span class="keyword">return</span> result.isEmpty() ? emptyList() : result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="N"><a href="#N" class="headerlink" title="# $N"></a># $N</h5><p>生成的代码通常是自引用的。使用 <code>$N</code> 通过其名称引用另一个生成的声明。这是一个调用另一个的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">byteToHex</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">  result[<span class="number">0</span>] = hexDigit((b &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>);</span><br><span class="line">  result[<span class="number">1</span>] = hexDigit(b &amp; <span class="number">0xf</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">hexDigit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">char</span>) (i &lt; <span class="number">10</span> ? i + <span class="string">&#x27;0&#x27;</span> : i - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生成上面的代码时，我们使用 <code>$N</code> 将 <code>hexDigit()</code> 方法作为参数传递给 <code>byteToHex()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec hexDigit = MethodSpec.methodBuilder(<span class="string">&quot;hexDigit&quot;</span>)</span><br><span class="line">    .addParameter(<span class="keyword">int</span>.class, <span class="string">&quot;i&quot;</span>)</span><br><span class="line">    .returns(<span class="keyword">char</span>.class)</span><br><span class="line">    .addStatement(<span class="string">&quot;return (char) (i &lt; 10 ? i + &#x27;0&#x27; : i - 10 + &#x27;a&#x27;)&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">MethodSpec byteToHex = MethodSpec.methodBuilder(<span class="string">&quot;byteToHex&quot;</span>)</span><br><span class="line">    .addParameter(<span class="keyword">int</span>.class, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">    .returns(String.class)</span><br><span class="line">    .addStatement(<span class="string">&quot;char[] result = new char[2]&quot;</span>)</span><br><span class="line">    .addStatement(<span class="string">&quot;result[0] = $N((b &gt;&gt;&gt; 4) &amp; 0xf)&quot;</span>, hexDigit)</span><br><span class="line">    .addStatement(<span class="string">&quot;result[1] = $N(b &amp; 0xf)&quot;</span>, hexDigit)</span><br><span class="line">    .addStatement(<span class="string">&quot;return new String(result)&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="# 构造函数"></a># 构造函数</h5><p>使用 <code>MethodSpec</code> 也可以生成类的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec flux = MethodSpec.constructorBuilder()</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addParameter(String.class, <span class="string">&quot;greeting&quot;</span>)</span><br><span class="line">    .addStatement(<span class="string">&quot;this.$N = $N&quot;</span>, <span class="string">&quot;greeting&quot;</span>, <span class="string">&quot;greeting&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(String.class, <span class="string">&quot;greeting&quot;</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .addMethod(flux)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String greeting;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(String greeting)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="# 参数"></a># 参数</h5><p>使用 <code>ParameterSpec.builder()</code> 或 <code>MethodSpec</code> 的 API <code>addParameter()</code> 在方法和构造函数上声明参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ParameterSpec android = ParameterSpec.builder(String.class, <span class="string">&quot;android&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">MethodSpec welcomeOverlords = MethodSpec.methodBuilder(<span class="string">&quot;welcomeOverlords&quot;</span>)</span><br><span class="line">    .addParameter(android)</span><br><span class="line">    .addParameter(String.class, <span class="string">&quot;robot&quot;</span>, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcomeOverlords</span><span class="params">(<span class="keyword">final</span> String android, <span class="keyword">final</span> String robot)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字段"><a href="#字段" class="headerlink" title="# 字段"></a># 字段</h5><p>使用 <code>FieldSpec#builder()</code> 或 <code>TypeSpec#addField()</code> 生成字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FieldSpec android = FieldSpec.builder(String.class, <span class="string">&quot;android&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(android)</span><br><span class="line">    .addField(String.class, <span class="string">&quot;robot&quot;</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String android;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String robot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接口"><a href="#接口" class="headerlink" title="# 接口"></a># 接口</h5><p>对于 <code>JavaPoet</code> 的接口，请注意，接口方法必须始终为 <code>PUBLIC ABSTRACT</code>，并且接口字段必须始终为 <code>PUBLIC STATIC FINAL</code>。定义接口时，必须使用以下修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.interfaceBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(FieldSpec.builder(String.class, <span class="string">&quot;ONLY_THING_THAT_IS_CONSTANT&quot;</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">        .initializer(<span class="string">&quot;$S&quot;</span>, <span class="string">&quot;change&quot;</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">&quot;beep&quot;</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>但是，在生成代码时将省略这些修饰符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  String ONLY_THING_THAT_IS_CONSTANT = <span class="string">&quot;change&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">beep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举"><a href="#枚举" class="headerlink" title="# 枚举"></a># 枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TypeSpec helloWorld = TypeSpec.enumBuilder(<span class="string">&quot;Roshambo&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addEnumConstant(<span class="string">&quot;ROCK&quot;</span>)</span><br><span class="line">    .addEnumConstant(<span class="string">&quot;SCISSORS&quot;</span>)</span><br><span class="line">    .addEnumConstant(<span class="string">&quot;PAPER&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Roshambo</span> </span>&#123;</span><br><span class="line">  ROCK,</span><br><span class="line"></span><br><span class="line">  SCISSORS,</span><br><span class="line"></span><br><span class="line">  PAPER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>JavaPoet</code> 还有挺多细节的生成规则，建议感兴趣的小伙伴可以阅读 <code>JavaPoet</code> 的官方文档。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/square/javapoet&quot;&gt;JavaPoet&lt;/a&gt; is a Java API for generating .java source files.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="https://hndroid.github.io/categories/Java/"/>
    
    
    <category term="APT" scheme="https://hndroid.github.io/tags/APT/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系类-合并型操作符实战</title>
    <link href="https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E7%B1%BB-%E5%90%88%E5%B9%B6%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/"/>
    <id>https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E7%B1%BB-%E5%90%88%E5%B9%B6%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/</id>
    <published>2020-04-09T01:38:16.000Z</published>
    <updated>2021-06-20T11:52:16.133Z</updated>
    
    <content type="html"><![CDATA[<h5 id="startWith"><a href="#startWith" class="headerlink" title="# startWith()"></a># startWith()</h5><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxStartWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            emitter.onNext(<span class="number">10</span>);</span><br><span class="line">            emitter.onNext(<span class="number">20</span>);</span><br><span class="line">            emitter.onNext(<span class="number">30</span>);</span><br><span class="line">            emitter.onNext(<span class="number">40</span>);</span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).startWith(Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            emitter.onNext(<span class="number">1000</span>);</span><br><span class="line">            emitter.onNext(<span class="number">2000</span>);</span><br><span class="line">            emitter.onNext(<span class="number">3000</span>);</span><br><span class="line">            emitter.onNext(<span class="number">4000</span>);</span><br><span class="line">            <span class="comment">// 发射事件完成以后，必须加上 emitter.onComplete()，不然不会执行合并操作另外一个被观察者</span></span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer pInteger)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;合并型操作符 startWith &quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pInteger);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        04-05 20:48:21.479 29474-29474/com.example.learnrxjava D/合并型操作符 startWith: accept: ----&gt; 1000</span></span><br><span class="line"><span class="comment">//        04-05 20:48:21.479 29474-29474/com.example.learnrxjava D/合并型操作符 startWith: accept: ----&gt; 2000</span></span><br><span class="line"><span class="comment">//        04-05 20:48:21.479 29474-29474/com.example.learnrxjava D/合并型操作符 startWith: accept: ----&gt; 3000</span></span><br><span class="line"><span class="comment">//        04-05 20:48:21.479 29474-29474/com.example.learnrxjava D/合并型操作符 startWith: accept: ----&gt; 4000</span></span><br><span class="line"><span class="comment">//        04-05 20:48:21.479 29474-29474/com.example.learnrxjava D/合并型操作符 startWith: accept: ----&gt; 10</span></span><br><span class="line"><span class="comment">//        04-05 20:48:21.479 29474-29474/com.example.learnrxjava D/合并型操作符 startWith: accept: ----&gt; 20</span></span><br><span class="line"><span class="comment">//        04-05 20:48:21.479 29474-29474/com.example.learnrxjava D/合并型操作符 startWith: accept: ----&gt; 30</span></span><br><span class="line"><span class="comment">//        04-05 20:48:21.479 29474-29474/com.example.learnrxjava D/合并型操作符 startWith: accept: ----&gt; 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并操作符 <code>startWith()</code> 可以看着：<code>Observable_1.startWith(Observable_2)</code>, 其执行的顺序是先发射 <code>Observable_2</code> 里面的事件，在调用完 <code>onComplete()</code> 方法以后，再去发射 <code>Observable_1</code> 里面的事件。</p><h5 id="concatWith"><a href="#concatWith" class="headerlink" title="# concatWith()"></a># concatWith()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxConcatWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            emitter.onNext(<span class="number">10</span>);</span><br><span class="line">            emitter.onNext(<span class="number">20</span>);</span><br><span class="line">            emitter.onNext(<span class="number">30</span>);</span><br><span class="line">            emitter.onNext(<span class="number">40</span>);</span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).concatWith(Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            emitter.onNext(<span class="number">1000</span>);</span><br><span class="line">            emitter.onNext(<span class="number">2000</span>);</span><br><span class="line">            emitter.onNext(<span class="number">3000</span>);</span><br><span class="line">            emitter.onNext(<span class="number">4000</span>);</span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer pInteger)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;合并型操作符&quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pInteger);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        04-05 20:59:25.607 620-620/com.example.learnrxjava D/合并型操作符: accept: ----&gt; 10</span></span><br><span class="line"><span class="comment">//        04-05 20:59:25.607 620-620/com.example.learnrxjava D/合并型操作符: accept: ----&gt; 20</span></span><br><span class="line"><span class="comment">//        04-05 20:59:25.607 620-620/com.example.learnrxjava D/合并型操作符: accept: ----&gt; 30</span></span><br><span class="line"><span class="comment">//        04-05 20:59:25.607 620-620/com.example.learnrxjava D/合并型操作符: accept: ----&gt; 40</span></span><br><span class="line"><span class="comment">//        04-05 20:59:25.607 620-620/com.example.learnrxjava D/合并型操作符: accept: ----&gt; 1000</span></span><br><span class="line"><span class="comment">//        04-05 20:59:25.607 620-620/com.example.learnrxjava D/合并型操作符: accept: ----&gt; 2000</span></span><br><span class="line"><span class="comment">//        04-05 20:59:25.607 620-620/com.example.learnrxjava D/合并型操作符: accept: ----&gt; 3000</span></span><br><span class="line"><span class="comment">//        04-05 20:59:25.607 620-620/com.example.learnrxjava D/合并型操作符: accept: ----&gt; 4000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并操作符 <code>concatWith()</code> 可以看着表达式: <code>Observable_1.concatWith(Observable_2)</code>, 与上面的 <code>startWith()</code> 不同的是，<code>concatWith()</code> 会先发射 <code>Observable_1</code> 里面的事件，然后再发射 <code>Observable_2</code> 里面的事件。</p><h5 id="concat"><a href="#concat" class="headerlink" title="# concat()"></a># concat()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxConcat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable.concat(</span><br><span class="line">            Observable.just(<span class="number">10</span>)</span><br><span class="line">            ,</span><br><span class="line">            Observable.just(<span class="number">20</span>)</span><br><span class="line">            ,</span><br><span class="line">            Observable.just(<span class="number">30</span>)</span><br><span class="line">            ,</span><br><span class="line">            Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    emitter.onNext(<span class="number">40</span>);</span><br><span class="line">                    emitter.onComplete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    ).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer pInteger)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;合并型操作符 concat &quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pInteger);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        04-05 21:10:42.198 5139-5139/com.example.learnrxjava D/合并型操作符 concat: accept: ----&gt; 10</span></span><br><span class="line"><span class="comment">//        04-05 21:10:42.198 5139-5139/com.example.learnrxjava D/合并型操作符 concat: accept: ----&gt; 20</span></span><br><span class="line"><span class="comment">//        04-05 21:10:42.198 5139-5139/com.example.learnrxjava D/合并型操作符 concat: accept: ----&gt; 30</span></span><br><span class="line"><span class="comment">//        04-05 21:10:42.198 5139-5139/com.example.learnrxjava D/合并型操作符 concat: accept: ----&gt; 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并型操作符 <code>concat()</code> 是把被观察者按顺序执行的，但最多只能同时四个被观察者进行合并。</p><h5 id="merge"><a href="#merge" class="headerlink" title="# merge()"></a># merge()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxMerge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@NonNull</span> Observable&lt;Long&gt; lObservable_1 = Observable.intervalRange(<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span> Observable&lt;Long&gt; lObservable_2 = Observable.intervalRange(<span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span> Observable&lt;Long&gt; lObservable_3 = Observable.intervalRange(<span class="number">11</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    Observable.merge(lObservable_1, lObservable_2, lObservable_3)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long pLong)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;合并型操作符 merge &quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pLong);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        04-05 21:25:52.151 10863-10912/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 1</span></span><br><span class="line"><span class="comment">//        04-05 21:25:52.154 10863-10914/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 11</span></span><br><span class="line"><span class="comment">//        04-05 21:25:52.155 10863-10913/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 6</span></span><br><span class="line"><span class="comment">//        04-05 21:25:54.148 10863-10912/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 2</span></span><br><span class="line"><span class="comment">//        04-05 21:25:54.149 10863-10913/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 7</span></span><br><span class="line"><span class="comment">//        04-05 21:25:54.149 10863-10914/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 12</span></span><br><span class="line"><span class="comment">//        04-05 21:25:56.148 10863-10912/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 3</span></span><br><span class="line"><span class="comment">//        04-05 21:25:56.148 10863-10913/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 8</span></span><br><span class="line"><span class="comment">//        04-05 21:25:56.149 10863-10914/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 13</span></span><br><span class="line"><span class="comment">//        04-05 21:25:58.148 10863-10912/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 4</span></span><br><span class="line"><span class="comment">//        04-05 21:25:58.149 10863-10913/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 9</span></span><br><span class="line"><span class="comment">//        04-05 21:25:58.149 10863-10914/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 14</span></span><br><span class="line"><span class="comment">//        04-05 21:26:00.148 10863-10912/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 5</span></span><br><span class="line"><span class="comment">//        04-05 21:26:00.149 10863-10913/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 10</span></span><br><span class="line"><span class="comment">//        04-05 21:26:00.150 10863-10914/com.example.learnrxjava D/合并型操作符 merge: accept: ----&gt; 15</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并型操作符 <code>merge()</code> 和 <code>concat()</code> 一样，也是最多可以合并四个被观察者，但是被合并的被观察者发射的事件是并发发射的。</p><h5 id="zip"><a href="#zip" class="headerlink" title="# zip()"></a># zip()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxZip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span> Observable&lt;String&gt; lStringObservable_1 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            emitter.onNext(<span class="string">&quot;Android开发&quot;</span>);</span><br><span class="line">            emitter.onNext(<span class="string">&quot;Java开发&quot;</span>);</span><br><span class="line">            emitter.onNext(<span class="string">&quot;Web开发&quot;</span>);</span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span> Observable&lt;String&gt; lStringObservable_2 = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            emitter.onNext(<span class="string">&quot;12K&quot;</span>);</span><br><span class="line">            emitter.onNext(<span class="string">&quot;13K&quot;</span>);</span><br><span class="line">            emitter.onNext(<span class="string">&quot;14K&quot;</span>);</span><br><span class="line">            <span class="comment">// 在 lStringObservable_1 没有职位与 15K 对应</span></span><br><span class="line">            emitter.onNext(<span class="string">&quot;15K&quot;</span>);</span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Observable.zip(lStringObservable_1, lStringObservable_2, <span class="keyword">new</span> BiFunction&lt;String, String, StringBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> StringBuffer <span class="title">apply</span><span class="params">(String pS, String pS2)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;职位: &quot;</span>).append(pS).append(<span class="string">&quot; -----&gt; &quot;</span>).append(<span class="string">&quot;工资：&quot;</span>).append(pS2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;StringBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(StringBuffer pStringBuffer)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;合并型操作符 zip &quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pStringBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        04-05 21:38:03.910 14403-14403/com.example.learnrxjava D/合并型操作符 zip: accept: ----&gt; 职位: Android开发 -----&gt; 工资：12K</span></span><br><span class="line"><span class="comment">//        04-05 21:38:03.910 14403-14403/com.example.learnrxjava D/合并型操作符 zip: accept: ----&gt; 职位: Java开发 -----&gt; 工资：13K</span></span><br><span class="line"><span class="comment">//        04-05 21:38:03.910 14403-14403/com.example.learnrxjava D/合并型操作符 zip: accept: ----&gt; 职位: Web开发 -----&gt; 工资：14K</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并型操作符 <code>zip()</code> 最多可以同时合并 9 个被观察者，但每个被观察者里面的事件需要数量相同，换而言之，就是需要被观察者里面的事件一一对应。</p><p><img src="http://baihonghua.cn/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;startWith&quot;&gt;&lt;a href=&quot;#startWith&quot; class=&quot;headerlink&quot; title=&quot;# startWith()&quot;&gt;&lt;/a&gt;# startWith()&lt;/h5&gt;</summary>
    
    
    
    <category term="Android开源库" scheme="https://hndroid.github.io/categories/Android%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="RxJava" scheme="https://hndroid.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列-条件型操作符实战</title>
    <link href="https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E5%88%97-%E6%9D%A1%E4%BB%B6%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/"/>
    <id>https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E5%88%97-%E6%9D%A1%E4%BB%B6%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/</id>
    <published>2020-04-09T01:37:16.000Z</published>
    <updated>2021-06-20T11:52:16.132Z</updated>
    
    <content type="html"><![CDATA[<h5 id="all"><a href="#all" class="headerlink" title="# all()"></a># all()</h5><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Observable.just(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">            .all(<span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> !pS.equals(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean pBoolean)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;条件型操作符 all&quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pBoolean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 22:54:14.364 25017-25017/com.example.learnrxjava D/条件型操作符 all: accept: ----&gt; true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件型操作符 <code>all()</code> 只有上游发射的事件都满足 <code>true</code> 才完下游发射 <code>true</code>, 如果有一个事件不满足，则返回 <code>false</code>。</p><h5 id="any"><a href="#any" class="headerlink" title="# any()"></a># any()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxAny</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Observable.just(<span class="string">&quot;JavaSE&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line">            .any(<span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> pS.equals(<span class="string">&quot;Android&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Boolean pBoolean)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;条件型操作符 any&quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pBoolean);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//04-05 17:46:12.981 9714-9714/com.example.learnrxjava D/条件型操作符 any: accept: ----&gt; false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>条件型操作符 <code>any()</code> 全部为 <code>false</code> 才是 <code>false</code>, 只有一个为 <code>true</code> 就是 <code>true</code>。如果在上游使用了条件操作符，那么在下游接收的类型是条件类型（boolean）。</p><p><img src="http://baihonghua.cn/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;all&quot;&gt;&lt;a href=&quot;#all&quot; class=&quot;headerlink&quot; title=&quot;# all()&quot;&gt;&lt;/a&gt;# all()&lt;/h5&gt;</summary>
    
    
    
    <category term="Android开源库" scheme="https://hndroid.github.io/categories/Android%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="RxJava" scheme="https://hndroid.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列-过滤型操作符实战</title>
    <link href="https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E5%88%97-%E8%BF%87%E6%BB%A4%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/"/>
    <id>https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E5%88%97-%E8%BF%87%E6%BB%A4%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/</id>
    <published>2020-04-09T01:35:56.000Z</published>
    <updated>2021-06-20T11:52:16.132Z</updated>
    
    <content type="html"><![CDATA[<h5 id="filter"><a href="#filter" class="headerlink" title="# filter()"></a># filter()</h5><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Observable.just(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C#&quot;</span>)</span><br><span class="line">            .filter(<span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;Java&quot;</span>.equals(pS)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;过滤型操作符 filter&quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 21:40:41.583 6754-6754/com.example.learnrxjava D/过滤型操作符 filter: accept: ----&gt; C++</span></span><br><span class="line"><span class="comment">//        2020-04-04 21:40:41.583 6754-6754/com.example.learnrxjava D/过滤型操作符 filter: accept: ----&gt; C#</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤操作符 <code>filter()</code> 作为中间的节点，回去拦截上游发送出来的事件，然后根据 <code>false</code> 或 <code>true</code> 条件继续发送往下游。<code>false</code> 表示事件被拦截不再往下发射。</p><h5 id="take"><a href="#take" class="headerlink" title="# take()"></a># take()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxTake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Observable.interval(<span class="number">0</span>, TimeUnit.SECONDS)</span><br><span class="line">            .take(<span class="number">8</span>)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long pLong)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;过滤型操作符 take &quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pLong);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 22:00:16.109 9270-9302/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 0</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:00:16.109 9270-9302/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 1</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:00:16.109 9270-9302/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 2</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:00:16.110 9270-9302/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 3</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:00:16.110 9270-9302/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 4</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:00:16.110 9270-9302/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 5</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:00:16.110 9270-9302/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 6</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:00:16.110 9270-9302/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤操作符 <code>take()</code> 主要是在定时器的基础上，才可以体现 <code>take()</code> 过滤操作符的意义。</p><p>然后下面代码实战实现一个倒计时的小栗子，分别用到了定时器 <code>interval()</code>、<code>take()</code>、<code>map()</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxTake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Observable.interval(<span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            .take(num)</span><br><span class="line">            .map(<span class="keyword">new</span> Function&lt;Long, Long&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Long pLong)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> num - pLong;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long pLong)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;过滤型操作符 take &quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pLong);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:32.687 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 10</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:33.693 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 9</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:34.725 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 8</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:35.727 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 7</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:36.697 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 6</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:37.724 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 5</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:38.719 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 4</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:39.719 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 3</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:40.727 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 2</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:22:41.727 16087-16129/com.example.learnrxjava D/过滤型操作符 take: accept: ----&gt; 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="distinct"><a href="#distinct" class="headerlink" title="# distinct()"></a># distinct()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxDistinct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            emitter.onNext(<span class="number">1</span>);</span><br><span class="line">            emitter.onNext(<span class="number">2</span>);</span><br><span class="line">            emitter.onNext(<span class="number">2</span>);</span><br><span class="line">            emitter.onNext(<span class="number">3</span>);</span><br><span class="line">            emitter.onNext(<span class="number">4</span>);</span><br><span class="line">            emitter.onNext(<span class="number">4</span>);</span><br><span class="line">            emitter.onNext(<span class="number">4</span>);</span><br><span class="line">            emitter.onNext(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).distinct()</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer pInteger)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;过滤型操作符 distinct&quot;</span>, <span class="string">&quot;accept: &quot;</span> + pInteger);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 22:32:18.745 21380-21380/com.example.learnrxjava D/过滤型操作符 distinct: accept: 1</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:32:18.745 21380-21380/com.example.learnrxjava D/过滤型操作符 distinct: accept: 2</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:32:18.745 21380-21380/com.example.learnrxjava D/过滤型操作符 distinct: accept: 3</span></span><br><span class="line"><span class="comment">//        2020-04-04 22:32:18.746 21380-21380/com.example.learnrxjava D/过滤型操作符 distinct: accept: 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤操作符 <code>distinct()</code> 主要的作用是把上游重复的事件过滤。</p><h5 id="elementAt"><a href="#elementAt" class="headerlink" title="# elementAt()"></a># elementAt()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxElementAt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            emitter.onNext(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            emitter.onNext(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">            emitter.onNext(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">            emitter.onNext(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">            emitter.onNext(<span class="string">&quot;Kotlin&quot;</span>);</span><br><span class="line">            emitter.onNext(<span class="string">&quot;Kotlin&quot;</span>);</span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).elementAt(<span class="number">0</span>)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;过滤型操作符 elementAt &quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 22:42:15.205 23692-23692/com.example.learnrxjava D/过滤型操作符 elementAt: accept: ----&gt; C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤操作符 <code>elementAt()</code> 用于输出指定下标的事件，还可以指定默认的值，如果指定的下标的事件不存在，则输出指定的默认值。</p><p><img src="http://baihonghua.cn/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;filter&quot;&gt;&lt;a href=&quot;#filter&quot; class=&quot;headerlink&quot; title=&quot;# filter()&quot;&gt;&lt;/a&gt;# filter()&lt;/h5&gt;</summary>
    
    
    
    <category term="Android开源库" scheme="https://hndroid.github.io/categories/Android%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="RxJava" scheme="https://hndroid.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列-变换型操作符实战</title>
    <link href="https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E5%88%97-%E5%8F%98%E6%8D%A2%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/"/>
    <id>https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E5%88%97-%E5%8F%98%E6%8D%A2%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/</id>
    <published>2020-04-09T01:34:47.000Z</published>
    <updated>2021-06-20T11:52:16.132Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在 RxJava 中，上游和下游的界限有时候并不是很明显。我的理解是：RxJava 的上下游的区分需要以观察者为比较的参照物，在观察者的之前的，都是可以看着上游。</p><p>如下面的 <code>map()</code> 变换操作符，<code>just()</code> 和 <code>map()</code> 操作符都可以看着上游，因为观察者订阅事件是发生在 <code>Consumer</code> 匿名对象中。</p><span id="more"></span><h4 id="变换型操作符实战"><a href="#变换型操作符实战" class="headerlink" title="变换型操作符实战"></a>变换型操作符实战</h4><h5 id="map"><a href="#map" class="headerlink" title="# map()"></a># map()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)<span class="comment">// 生产事件</span></span><br><span class="line">            <span class="comment">// 变换事件</span></span><br><span class="line">            .map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer pInteger)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;[ &quot;</span> + pInteger + <span class="string">&quot; ]&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 观察者订阅事件</span></span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;变换型操作符 map &quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 16:11:18.227 9596-9596/com.example.learnrxjava D/变换型操作符 map: accept: ----&gt; [ 1 ]</span></span><br><span class="line"><span class="comment">//        2020-04-04 16:11:18.227 9596-9596/com.example.learnrxjava D/变换型操作符 map: accept: ----&gt; [ 2 ]</span></span><br><span class="line"><span class="comment">//        2020-04-04 16:11:18.228 9596-9596/com.example.learnrxjava D/变换型操作符 map: accept: ----&gt; [ 3 ]</span></span><br><span class="line"><span class="comment">//        2020-04-04 16:11:18.228 9596-9596/com.example.learnrxjava D/变换型操作符 map: accept: ----&gt; [ 4 ]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作符 <code>map()</code> 可以看着上下游的之间的节点，把上游的 <code>Integer</code> 类型的变量，变换为 <code>String</code> 类型的字符串，而 <code>map()</code> 作为中间的节点可以变换上游的事件性质；</p><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="# flatMap()"></a># flatMap()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxFlatMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String[] lStrings = &#123;<span class="string">&quot;learn &quot;</span>, <span class="string">&quot;RxJava&#x27;s &quot;</span>, <span class="string">&quot;Op&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Observable.fromArray(lStrings)</span><br><span class="line">            .flatMap(<span class="keyword">new</span> Function&lt;String, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;String&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> String&gt; observer)</span> </span>&#123;</span><br><span class="line">                            observer.onNext(pS + <span class="string">&quot;// &quot;</span>);</span><br><span class="line">                            observer.onNext(pS + <span class="string">&quot;== &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="meta">@NonNull</span> String pS)</span> </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;变换型操作符 onNext&quot;</span>, <span class="string">&quot;onNext: ----&gt; &quot;</span> + pS);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 16:49:36.806 26443-26443/? D/变换型操作符 onNext: onNext: ----&gt; learn // </span></span><br><span class="line"><span class="comment">//        2020-04-04 16:49:36.806 26443-26443/? D/变换型操作符 onNext: onNext: ----&gt; learn == </span></span><br><span class="line"><span class="comment">//        2020-04-04 16:49:36.806 26443-26443/? D/变换型操作符 onNext: onNext: ----&gt; RxJava&#x27;s // </span></span><br><span class="line"><span class="comment">//        2020-04-04 16:49:36.806 26443-26443/? D/变换型操作符 onNext: onNext: ----&gt; RxJava&#x27;s == </span></span><br><span class="line"><span class="comment">//        2020-04-04 16:49:36.806 26443-26443/? D/变换型操作符 onNext: onNext: ----&gt; Op// </span></span><br><span class="line"><span class="comment">//        2020-04-04 16:49:36.806 26443-26443/? D/变换型操作符 onNext: onNext: ----&gt; Op==</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>操作符 <code>flatMap</code> 作为 RxJava 的中介节点，可以像 <code>map()</code> 操作一样，变换上游的事件性质，同时在还可以通过 <code>ObservableSource&lt;?&gt;&gt;()</code> 在变换事件性质的同时，同时向下游多次发射事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxFlatMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] lStrings = &#123;<span class="string">&quot;learn &quot;</span>, <span class="string">&quot;RxJava&#x27;s &quot;</span>, <span class="string">&quot;Op&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Observable.fromArray(lStrings)</span><br><span class="line">                .flatMap(<span class="keyword">new</span> Function&lt;String, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                        List&lt;String&gt; lStringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                            lStringList.add(pS + <span class="string">&quot;下标 &quot;</span> + <span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">                        <span class="keyword">return</span> Observable.fromIterable(lStringList).delay(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="meta">@NonNull</span> String pS)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;变换型操作符 onNext&quot;</span>, <span class="string">&quot;onNext: ----&gt; &quot;</span> + pS);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.488 27958-27989/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; learn 下标 [0]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.489 27958-27989/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; learn 下标 [1]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.490 27958-27989/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; learn 下标 [2]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.491 27958-27989/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; learn 下标 [3]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.492 27958-27989/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; learn 下标 [4]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.493 27958-27990/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; RxJava&#x27;s 下标 [0]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.494 27958-27990/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; RxJava&#x27;s 下标 [1]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.494 27958-27991/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; Op下标 [0]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.495 27958-27990/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; RxJava&#x27;s 下标 [2]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.495 27958-27991/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; Op下标 [1]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.496 27958-27990/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; RxJava&#x27;s 下标 [3]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.497 27958-27991/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; Op下标 [2]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.497 27958-27991/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; RxJava&#x27;s 下标 [4]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.498 27958-27991/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; Op下标 [3]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:08:55.499 27958-27991/com.example.learnrxjava D/变换型操作符 onNext: onNext: ----&gt; Op下标 [4]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>操作符 <code>flatMap()</code> 在把上游的事件变换为多个事件继续向下游发射的同时，并不是顺序向下游发射的。</p><h5 id="concatMap"><a href="#concatMap" class="headerlink" title="# concatMap()"></a># concatMap()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxConcatMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable.just(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BBBB&quot;</span>, <span class="string">&quot;CVD&quot;</span>)</span><br><span class="line">            .concatMap(<span class="keyword">new</span> Function&lt;String, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    List&lt;String&gt; lStringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                        lStringList.add(pS + <span class="string">&quot;下标 &quot;</span> + <span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> Observable.fromIterable(lStringList).delay(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String pS)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;变换型操作符 concatMap&quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:22.629 29058-29091/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; AA下标 [0]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:22.630 29058-29091/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; AA下标 [1]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:22.630 29058-29091/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; AA下标 [2]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:22.630 29058-29091/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; AA下标 [3]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:22.630 29058-29091/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; AA下标 [4]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:27.665 29058-29095/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; BBBB下标 [0]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:27.667 29058-29095/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; BBBB下标 [1]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:27.667 29058-29095/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; BBBB下标 [2]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:27.668 29058-29095/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; BBBB下标 [3]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:27.669 29058-29095/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; BBBB下标 [4]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:32.706 29058-29105/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; CVD下标 [0]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:32.707 29058-29105/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; CVD下标 [1]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:32.708 29058-29105/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; CVD下标 [2]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:32.709 29058-29105/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; CVD下标 [3]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:18:32.709 29058-29105/com.example.learnrxjava D/变换型操作符 concatMap: accept: ----&gt; CVD下标 [4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变换操作符 <code>concatMap()</code> 和 <code>flatMap()</code> 操作符的功能一样，也是可以把上游的事件变换成多个事件向下游发送，但是 <code>concatMap()</code> 在多次发射事件的时候，是排序向下游发送的。</p><h5 id="groupBy"><a href="#groupBy" class="headerlink" title="# groupBy()"></a># groupBy()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxGroupBy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Observable.just(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line">            .groupBy(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer pInteger)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> pInteger &gt; <span class="number">30</span> ? <span class="string">&quot;中年程序员&quot;</span> : <span class="string">&quot;年轻的程序员&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;GroupedObservable&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> GroupedObservable&lt;String, Integer&gt; pGroupedObservable)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                    Log.d(<span class="string">&quot;分类的 Key &quot;</span>, <span class="string">&quot;accept: &quot;</span> + pGroupedObservable.getKey());</span><br><span class="line"></span><br><span class="line">                    pGroupedObservable.subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer pInteger)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                            Log.d(<span class="string">&quot;变换操作符 groupBy&quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pGroupedObservable.getKey() + <span class="string">&quot;年龄 ：&quot;</span> + pInteger);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 17:32:21.656 3023-3023/com.example.learnrxjava D/分类的 Key: accept: 年轻的程序员</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:32:21.656 3023-3023/com.example.learnrxjava D/变换操作符 groupBy: accept: ----&gt; 年轻的程序员年龄 ：10</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:32:21.657 3023-3023/com.example.learnrxjava D/变换操作符 groupBy: accept: ----&gt; 年轻的程序员年龄 ：20</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:32:21.657 3023-3023/com.example.learnrxjava D/变换操作符 groupBy: accept: ----&gt; 年轻的程序员年龄 ：30</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:32:21.657 3023-3023/com.example.learnrxjava D/分类的 Key: accept: 中年程序员</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:32:21.657 3023-3023/com.example.learnrxjava D/变换操作符 groupBy: accept: ----&gt; 中年程序员年龄 ：40</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:32:21.658 3023-3023/com.example.learnrxjava D/变换操作符 groupBy: accept: ----&gt; 中年程序员年龄 ：50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作符 <code>groupBy()</code> 的作用主要是在其节点中，把上游的事件按照一定的标准分类成 <code>group</code>，然后再发送往下游。但下游需要按照一定的模板才可以把 <code>group</code> 分类出来。</p><h5 id="buffer"><a href="#buffer" class="headerlink" title="# buffer()"></a># buffer()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lI = <span class="number">0</span>; lI &lt; <span class="number">100</span>; lI++) &#123;</span><br><span class="line">                emitter.onNext(lI);</span><br><span class="line">            &#125;</span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">            .buffer(<span class="number">20</span>)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(List&lt;Integer&gt; pIntegers)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;变换操作符 buffer&quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + pIntegers);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-04 17:49:38.264 13267-13267/com.example.learnrxjava D/变换操作符 buffer: accept: ----&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:49:38.264 13267-13267/com.example.learnrxjava D/变换操作符 buffer: accept: ----&gt; [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:49:38.265 13267-13267/com.example.learnrxjava D/变换操作符 buffer: accept: ----&gt; [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:49:38.265 13267-13267/com.example.learnrxjava D/变换操作符 buffer: accept: ----&gt; [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79]</span></span><br><span class="line"><span class="comment">//        2020-04-04 17:49:38.266 13267-13267/com.example.learnrxjava D/变换操作符 buffer: accept: ----&gt; [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上游有大量的事件发送下来的时候，如果需要先把事件缓存到指定的数量后，再往下游发送，则变换操作符 <code>buffer()</code> 可以做到先缓存事件到指定的数量，然后再把缓存的事件一起发送往下游。</p><p><img src="http://baihonghua.cn/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在 RxJava 中，上游和下游的界限有时候并不是很明显。我的理解是：RxJava 的上下游的区分需要以观察者为比较的参照物，在观察者的之前的，都是可以看着上游。&lt;/p&gt;
&lt;p&gt;如下面的 &lt;code&gt;map()&lt;/code&gt; 变换操作符，&lt;code&gt;just()&lt;/code&gt; 和 &lt;code&gt;map()&lt;/code&gt; 操作符都可以看着上游，因为观察者订阅事件是发生在 &lt;code&gt;Consumer&lt;/code&gt; 匿名对象中。&lt;/p&gt;</summary>
    
    
    
    <category term="Android开源库" scheme="https://hndroid.github.io/categories/Android%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="RxJava" scheme="https://hndroid.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列-创建型操作符实战</title>
    <link href="https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E5%88%97-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/"/>
    <id>https://hndroid.github.io/2020/04/09/RxJava%E7%B3%BB%E5%88%97-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E6%88%98/</id>
    <published>2020-04-09T01:32:44.000Z</published>
    <updated>2021-06-20T11:52:16.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在实战 RxJava 之前，先谈谈我自己对 RxJava 的理解，我们知道 RxJava 是基于观察者模式的，我们可以把 RxJava 的使用看着整体的一条链：</p><ul><li>在链的最上游：是生成、发送、或者发射事件的 <code>Observable</code>；</li><li>在链的最下游：是根据上游的生成、发送、或者发射事件来做出相对应的动作的 <code>Observer</code>;</li><li>在链的中游：作为中介的节点，变动上下游的性质，如线程的切换等；</li></ul><p>我想，挺多的小伙伴可能在刚接触 RxJava 的时候，会感到疑惑：为什么是被观察者（Observable）订阅（subscribe）观察者（Observer），而不是观察者订阅被观察者？</p><p>我认为可以这么理解吧：首先你需要知道 Android 是基于事件驱动模型的，也就是说程序的执行流程是根据用户的动作（例如用户的屏幕触摸）触发的事件决定的。程序的执行流程在 RxJava 中就好比作观察者做出的动作，用户触发的事件就好比作被观察者产生的事件，程序的执行流程是代码固死的了，而用户的动作则是不确定的，程序代码根据用户操作执行相应的代码（如用户点击声量按钮只会调整音量，而不会让手机关机）。</p><p>然后为什么不是观察者订阅被观察者，其实这只是这样的写法更加符合事件驱动编程，先把观察者的代码加载进内存，以等待被观察者的到来后（如网络请求后的响应），执行对应的代码，因为，你永远不知道你的明天会怎样，唯一的只能先做好准备去面对。</p><span id="more"></span><h4 id="创建操作符实践"><a href="#创建操作符实践" class="headerlink" title="创建操作符实践"></a>创建操作符实践</h4><h5 id="create"><a href="#create" class="headerlink" title="# create()"></a># create()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建型操作符: create</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            emitter.onNext(<span class="number">1</span>);</span><br><span class="line">            emitter.onNext(<span class="number">2</span>);</span><br><span class="line">            emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;创建型操作符: create&quot;</span>, <span class="string">&quot;onSubscribe: ----&gt; &quot;</span> + d.isDisposed());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="meta">@NonNull</span> Integer integer)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;创建型操作符: create&quot;</span>, <span class="string">&quot;onNext: ----&gt; &quot;</span> + integer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;创建型操作符: create&quot;</span>, <span class="string">&quot;onError: ----&gt; &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;创建型操作符: create&quot;</span>, <span class="string">&quot;onComplete: &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*********************************打印的结果***************************************/</span></span><br><span class="line"><span class="comment">//    2020-04-03 14:37:48.543 16088-16088/com.example.learnrxjava D/创建型操作符: create: onSubscribe: ----&gt; false</span></span><br><span class="line"><span class="comment">//    2020-04-03 14:37:48.543 16088-16088/com.example.learnrxjava D/创建型操作符: create: onNext: ----&gt; 1</span></span><br><span class="line"><span class="comment">//    2020-04-03 14:37:48.543 16088-16088/com.example.learnrxjava D/创建型操作符: create: onNext: ----&gt; 2</span></span><br><span class="line"><span class="comment">//    2020-04-03 14:37:48.543 16088-16088/com.example.learnrxjava D/创建型操作符: create: onComplete:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建类型的 <code>Observable#create()</code> 可以自己作为事件的生产者，往下游发送事件；</p><ul><li><p>在上游的 <code>onComplete()</code> 或 <code>onError()</code> 方法执行完以后，再通过 <code>onNext()</code> 发送事件，下游不在接收上游的事件；</p></li><li><p>上游已经发送了 <code>onComplete()</code> 以后再发送 <code>onError()</code>, RxJava 会报错；</p></li><li><p>上游先发送 <code>onError()</code>, 然后再发送 <code>onComplete()</code>，RxJava 不会报错，但下游不再接收 <code>onComplete()</code> 事件；</p></li></ul><h5 id="just"><a href="#just" class="headerlink" title="# just()"></a># just()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建型操作符： just</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxJust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;just&quot;</span>)</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符: just&quot;</span>, <span class="string">&quot;onSubscribe: ----&gt; &quot;</span> + d.isDisposed());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="meta">@NonNull</span> String s)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符: just&quot;</span>, <span class="string">&quot;onNext: ----&gt; &quot;</span> + s);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符: just&quot;</span>, <span class="string">&quot;onError: ----&gt; &quot;</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符: just&quot;</span>, <span class="string">&quot;onComplete: &quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-03 16:09:01.604 20917-20917/com.example.learnrxjava D/创建型操作符: just: onSubscribe: ----&gt; false</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:09:01.604 20917-20917/com.example.learnrxjava D/创建型操作符: just: onNext: ----&gt; test</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:09:01.605 20917-20917/com.example.learnrxjava D/创建型操作符: just: onNext: ----&gt; just</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:09:01.605 20917-20917/com.example.learnrxjava D/创建型操作符: just: onComplete:</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建型操作符 <code>Observable#just()</code> 在自己的内部发送事件，下游接收事件；</p><h5 id="fromArray"><a href="#fromArray" class="headerlink" title="# fromArray()"></a># fromArray()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建型操作符： fromArray</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxFromArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] str = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化版的下游接受者</span></span><br><span class="line">        Observable.fromArray(str)</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;简化版的下游观察者 Consumer&quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-03 16:20:17.701 27695-27695/com.example.learnrxjava D/简化版的下游观察者 Consumer: accept: ----&gt; 1</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:20:17.701 27695-27695/com.example.learnrxjava D/简化版的下游观察者 Consumer: accept: ----&gt; 2</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:20:17.701 27695-27695/com.example.learnrxjava D/简化版的下游观察者 Consumer: accept: ----&gt; 3</span></span><br><span class="line"></span><br><span class="line">        Observable.fromArray(str)</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符 fromArray&quot;</span>, <span class="string">&quot;onSubscribe: ----&gt; &quot;</span> + d.isDisposed());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="meta">@NonNull</span> String s)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符 fromArray&quot;</span>, <span class="string">&quot;onNext: ----&gt; &quot;</span> + s);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符 fromArray&quot;</span>, <span class="string">&quot;onError: ----&gt; &quot;</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符 fromArray&quot;</span>, <span class="string">&quot;onComplete:&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-03 16:23:49.046 28351-28351/com.example.learnrxjava D/创建型操作符 fromArray: onSubscribe: ----&gt; false</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:23:49.046 28351-28351/com.example.learnrxjava D/创建型操作符 fromArray: onNext: ----&gt; 1</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:23:49.046 28351-28351/com.example.learnrxjava D/创建型操作符 fromArray: onNext: ----&gt; 2</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:23:49.046 28351-28351/com.example.learnrxjava D/创建型操作符 fromArray: onNext: ----&gt; 3</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:23:49.046 28351-28351/com.example.learnrxjava D/创建型操作符 fromArray: onComplete:</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建型操作符 <code>Observable#fromArray()</code> 在自己的内部发射事件，但发射的对象需要是数组类型，因为在阅读 <code>Observable#fromArray()</code> 的源码可以发现，<code>Observable#fromArray()</code> 接收的参数是可变类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">fromArray</span><span class="params">(<span class="meta">@NonNull</span> T... items)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(items, <span class="string">&quot;items is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (items.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (items.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> just(items[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableFromArray&lt;&gt;(items));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="empty"><a href="#empty" class="headerlink" title="# empty()"></a># empty()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建型操作符： empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable.empty()</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Observer&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符 empty&quot;</span>, <span class="string">&quot;onSubscribe: ----&gt; &quot;</span> + d.isDisposed());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="meta">@NonNull</span> Object o)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符 empty&quot;</span>, <span class="string">&quot;onNext: ----&gt; &quot;</span> + o);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符 empty&quot;</span>, <span class="string">&quot;onError: ----&gt; &quot;</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.d(<span class="string">&quot;创建型操作符 empty&quot;</span>, <span class="string">&quot;onComplete&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-03 16:35:15.460 29156-29156/? D/创建类型操作符 empty: onSubscribe: ----&gt; true</span></span><br><span class="line"><span class="comment">//        2020-04-03 16:35:15.460 29156-29156/? D/创建类型操作符 empty: onComplete</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建型操作符 <code>Observable#empty()</code> 内部自己发送事件，下游默认是 Object，无法发出有值的事件，会发送 <code>onComplete()</code>；</p><h5 id="range"><a href="#range" class="headerlink" title="# range()"></a># range()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learnRxRange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable.range(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;创建型操作符 range&quot;</span>, <span class="string">&quot;accept: ----&gt; &quot;</span> + integer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2020-04-03 17:04:07.195 3103-3103/com.example.learnrxjava D/创建型操作符 range: accept: ----&gt; 10</span></span><br><span class="line"><span class="comment">//        2020-04-03 17:04:07.195 3103-3103/com.example.learnrxjava D/创建型操作符 range: accept: ----&gt; 11</span></span><br><span class="line"><span class="comment">//        2020-04-03 17:04:07.195 3103-3103/com.example.learnrxjava D/创建型操作符 range: accept: ----&gt; 12</span></span><br><span class="line"><span class="comment">//        2020-04-03 17:04:07.195 3103-3103/com.example.learnrxjava D/创建型操作符 range: accept: ----&gt; 13</span></span><br><span class="line"><span class="comment">//        2020-04-03 17:04:07.195 3103-3103/com.example.learnrxjava D/创建型操作符 range: accept: ----&gt; 14</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建型操作符  <code>Observable#range()</code> 会发送指定范围的 <code>int</code> 值的数值，如上面代码，开始为 <code>10</code>, 每次累加 <code>1</code>, 最后结果为: <code>10 11 12 13 14</code> 的 5 个值。</p><h4 id="Consumer和Observer"><a href="#Consumer和Observer" class="headerlink" title="Consumer和Observer"></a>Consumer和Observer</h4><p>可能有的小伙伴可能分不清 <code>Consumer</code> 和 <code>Observer</code> 两个类，其实可以把 <code>Consumer</code> 看着 <code>Observer</code> 简版的观察者，也是根据上游被观察者的行为变化而变化。</p><p><img src="http://baihonghua.cn/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在实战 RxJava 之前，先谈谈我自己对 RxJava 的理解，我们知道 RxJava 是基于观察者模式的，我们可以把 RxJava 的使用看着整体的一条链：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在链的最上游：是生成、发送、或者发射事件的 &lt;code&gt;Observable&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在链的最下游：是根据上游的生成、发送、或者发射事件来做出相对应的动作的 &lt;code&gt;Observer&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;在链的中游：作为中介的节点，变动上下游的性质，如线程的切换等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我想，挺多的小伙伴可能在刚接触 RxJava 的时候，会感到疑惑：为什么是被观察者（Observable）订阅（subscribe）观察者（Observer），而不是观察者订阅被观察者？&lt;/p&gt;
&lt;p&gt;我认为可以这么理解吧：首先你需要知道 Android 是基于事件驱动模型的，也就是说程序的执行流程是根据用户的动作（例如用户的屏幕触摸）触发的事件决定的。程序的执行流程在 RxJava 中就好比作观察者做出的动作，用户触发的事件就好比作被观察者产生的事件，程序的执行流程是代码固死的了，而用户的动作则是不确定的，程序代码根据用户操作执行相应的代码（如用户点击声量按钮只会调整音量，而不会让手机关机）。&lt;/p&gt;
&lt;p&gt;然后为什么不是观察者订阅被观察者，其实这只是这样的写法更加符合事件驱动编程，先把观察者的代码加载进内存，以等待被观察者的到来后（如网络请求后的响应），执行对应的代码，因为，你永远不知道你的明天会怎样，唯一的只能先做好准备去面对。&lt;/p&gt;</summary>
    
    
    
    <category term="Android开源库" scheme="https://hndroid.github.io/categories/Android%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="RxJava" scheme="https://hndroid.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列-虚拟机类加载机制</title>
    <link href="https://hndroid.github.io/2020/04/08/JVM%E7%B3%BB%E5%88%97-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://hndroid.github.io/2020/04/08/JVM%E7%B3%BB%E5%88%97-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-08T11:29:31.000Z</published>
    <updated>2021-06-20T11:52:16.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>虚拟机把描述的类的数据从 Class 文件加载进内存里面，同时对数据进行验证、解析、以及初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p><span id="more"></span><p>对类的类型进行加载、链接、和初始化的过程，是发生在程序的运行期间完成的，会使得类在加载时稍微增加一些额外的开销，但是这样使得 Java 这种语言具有可动态扩展的语言特性：</p><ul><li><p>如编写一个面向接口的应用程序，可以等到运行时在指定其实际的实现类；</p></li><li><p>如用户可以通过 Java 预定义或者自定义的类加载器，在程序运行时在其他地方加载二进制流作为程序的一部分；</p></li></ul><p>类从加载进虚拟机内存，到被虚拟机卸载的生命周期：</p><p><img src="http://baihonghua.cn/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>上图，类的生命周期里面的加载、验证、准备、以及初始化的顺序时确定的，而解析动作则在某些情况下，有可能在初始化之后才开始。这是为了支持 Java 语言运行时绑定。</p><p>类的生命周期各个阶段之间时互相交叉混合式进行的，通常在一个阶段调用、激活另外一个阶段。</p><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><h5 id="加载"><a href="#加载" class="headerlink" title="# 加载"></a># 加载</h5><p>虚拟机规范没有进行强制约束，交给虚拟机的具体实现来自行把握。在类加载阶段，虚拟机需要完成以下 3 件事情：</p><ul><li><p>通过一个类的全限定名来获取定义此类的二进制字节流；</p></li><li><p>将这个字节流所代表的静态结构转化为方法区的运行时的数据结构；</p></li><li><p>在内存中生成一个 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口；</p></li></ul><p>虚拟机规范的这三点并没有很具体，例如没有具体说到类的二进制字节流可以从哪里获取、以及如何获取，提供了很大的灵活性：</p><ul><li><p><strong>从 ZIP 包中获取</strong>，这最终成为日后 JAR、EAR、WAR格式的基础；</p></li><li><p><strong>从网络中获取</strong>，这种场景场景最典型的应用就是 Applet。</p></li><li><p><strong>运行时计算生成</strong>，这种场景使用最多的就是动态代理技术，在 <code>java.lang.reflect</code>。</p></li><li><p><strong>Proxy</strong> 中，就是用了 <code>ProxyGenerator.generateProxyClass</code> 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流。</p></li><li><p><strong>由其他文件生成</strong>，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</p></li><li><p><strong>从数据库中读取</strong>，这种场景相对少见些。</p></li></ul><p>非数组类的加载（即在加载的阶段获取二进制字节流的动作）的方式比较灵活，可以通过虚拟机预设的类加载器去加载，也可以通过自定义的类加载器去获取（通过重写类加载器的 <code>loadClass()</code> 方法）。</p><p>对于数组，因为数组不是通过类加载的方式创建的，它是直接通过虚拟机直接创建的，但数组的元素还是通过类加载器去创建的，一个数组类遵循以下规则：</p><ul><li><p>如果数组的组件类型（ComponentType，指的是数组去掉一个维度的类型）是应引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型。</p></li><li><p>如果数组的组件类型不是引用类型（如 int[] 数组），Java 虚拟机将会把数组标识为引导类加载器关联。</p></li><li><p>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那么数组类的可见性将默认为 public。</p></li></ul><h5 id="验证"><a href="#验证" class="headerlink" title="# 验证"></a># 验证</h5><p>验证阶段的主要的作用是确保 Class 文件的字节码中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证的阶段大致会完成下面的 4 个阶段：<strong>文件格式验证</strong>、<strong>元数据验证</strong>、<strong>字节码验证</strong>、<strong>符号引用验证</strong>。</p><ul><li><p><strong>文件格式验证</strong>主要是要验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机的所处理（部分），这个步骤主要是保证输入的字节流能正确地解析并存储于方法区之内：</p><ul><li>是否以魔数 0xCAFEBABE 开头；</li><li>主、次版本号是否在当前虚拟机处理范围之内；</li><li>常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）；</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；</li><li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF-8 编码的数据；</li><li>Class 文件中各个部分及文件本身是否有被删除的或被附加的其他信息；</li></ul></li><li><p><strong>元数据验证</strong>这个步骤主要是验证字节码描述的信息是否满足 Java 的语言规范，可能包含的验证点有（语法校验）：</p><ul><li>这个类是否有父类（除了 java.lang.Object 之外，所有的类都应该有父类）；</li><li>是否继承了不允许被继承的类（如继承了被 <code>final</code> 修饰的类）；</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现了不符合规定的方法重载，例如方法参数都一样，返回值却不相同）</li></ul></li><li><p><strong>字节码验证</strong>通过数据流、控制流分析，确定程序语意是合法的、符合逻辑的。在元数据验证步骤中主要对数据的类型进行验证之后，在字节码验证步骤则主要对类中的方法体进行验证分析，确保类的方法在运行时不会危害虚拟机：</p><ul><li><p>保证操作数栈的数据类型和指令代码序列都能配合工作，避免出现：在操作数栈放置一个 int 类型长度的数据变量，但却按 long 类型的来加载如本地变量表中；</p></li><li><p>保证跳转指令不会跳转到方法体以外的字节码指令上；</p></li><li><p>保证方法体中的转换是有效的；</p></li></ul></li><li><p><strong>符号引用验证</strong>这个步骤主要是在符号引用转化为直接引用之前，而这个转化的动作是发生在<strong>解析阶段</strong>，对字节码中的符号引用：如是否可以通过全限定名找到对应的类名、字段描述符是否对应方法名、简单名称是否对应字段、以及权限符（private、protected、pubilc、default）是否可被当前类访问。</p></li></ul><p><strong>字节码验证</strong>步骤对虚拟机加载机制来说是很重要的，但不是一定必须的，如某一份字节码已经经过多次使用和验证确保无误以后，可以通过 <code>-Xverify:none</code> 参数来关闭大部分的类的验证来减少类加载的时间。</p><h5 id="准备阶段"><a href="#准备阶段" class="headerlink" title="# 准备阶段"></a># 准备阶段</h5><p>准备阶段主要是为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。需要注意的是，在这里所指的类变量是指被 <code>static</code> 修饰符修饰的类变量，没有包括实例变量。实例变量将会在对象初始化的时候随着对象一起被分配 Java 堆中。同时，这里说的类变量的初始值通常为零值。如：</p><p><img src="http://baihonghua.cn/static%E5%AD%97%E6%AE%B5.png"></p><p>上述的代码的 <code>value</code> 在准备阶段初始值为 0 而不是 123，而被赋值为 123 的阶段是在初始化阶段的 <code>&lt;clinit&gt;()</code> 方法之中。</p><p><img src="http://baihonghua.cn/final%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5.png"></p><p>而当字段的属性表中存在 <code>ConstantValue</code> 属性的时候，那么在准备阶段虚拟机就会根据 <code>ConstantValue</code> 把 value 设置为 123；</p><table><thead><tr><th align="center">数据类型</th><th align="left">零值</th></tr></thead><tbody><tr><td align="center">int</td><td align="left">0</td></tr><tr><td align="center">long</td><td align="left">0L</td></tr><tr><td align="center">short</td><td align="left">(short)0</td></tr><tr><td align="center">char</td><td align="left">‘\u0000’</td></tr><tr><td align="center">byte</td><td align="left">(byte)0</td></tr><tr><td align="center">boolean</td><td align="left">false</td></tr><tr><td align="center">float</td><td align="left">0.0f</td></tr><tr><td align="center">double</td><td align="left">0.0d</td></tr><tr><td align="center">reference</td><td align="left">null</td></tr></tbody></table><h5 id="解析"><a href="#解析" class="headerlink" title="# 解析"></a># 解析</h5><p>解析阶段主要是把方法区内的常量池的符号引用转换为直接引用的过程。如把全限定名、字段描述符、简单名称转换为直接引用。</p><p><strong>符号引用</strong>指的是用一组符号来描述来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义地定位到目标即可。符号引用被明确定义在 Class 文件格式中。</p><p><strong>直接引用</strong>指的是可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果直接引用存在，那么引用的目标必定已经存在。</p><h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="# 初始化阶段"></a># 初始化阶段</h5><p>虚拟机规范明确规定有且只有 5 中情况必须立即对类进行初始化：</p><ul><li><p>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、或 <code>invokestatic</code> 这四条字节码指令时，如果类没有初始化，则需要先触发其初始化。生成这 4 条指令的最常见的 Java 代码场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放进常量池的静态常量除外）的时候，以及调用一个类的静态方法的时候。</p></li><li><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有初始化，则先对其父类进行初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</p></li><li><p>使用 JDK 1.7 的动态语言支持时，如果 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putstatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有初始化，则需要先触发其初始化。</p></li></ul><p>上面 5 种情况称为对一个类的主动引用。而所有引用类的方式都不会触发初始化，称为被动引用：</p><ul><li><p>通过子类引用父类的静态字段，不会导致子类的初始化；</p></li><li><p>通过数组定义来引用类，不会触发此类的初始化；</p></li><li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发类的初始化；</p></li></ul><p>接口与普通类的初始化，只和上面的 5 种主动引用的第三种情况不同（真正的区别）：普通类的初始化要求父类先初始化，而接口的父类只有在用到的时候（如引用接口中定义的定量）才会进行初始化。</p><p>初始化阶段是真正地执行定义的 Java 代码（或者说字节码）。在准备阶段类变量已经被赋过一次系统要求的初值，而在初始化阶段，这是初始化程序的类变量和其他的资源。初始化也可以说是<strong>执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程</strong>。 </p><p>下面是关于 <code>&lt;clinit&gt;()</code> 方法在执行过程中可能影响程序运行行为的特点和细节：</p><ul><li><p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的类变量和静态语句块中的语句合并而产生的。收集的顺序由语句在类文件中出现的顺序决定。</p></li><li><p>虚拟机会保证父类的 <code>&lt;clinit&gt;()</code> 方法先执行完毕，然后再执行子类的 <code>&lt;clinit&gt;()</code>，不需要我们显式调用，与实例构造器 <code>&lt;init&gt;()</code> 不同。因而在虚拟机中首先被调用的 <code>&lt;clinit&gt;()</code> 方法是在 <code>java.lang.Object</code>.</p></li><li><p>父类的静态语句优于子类的静态语句先执行。</p></li><li><p>接口中不可以定义静态语句块，但仍然有变量初始化的赋值操作，因此接口与类都会生成 <code>&lt;clinit&gt;()</code> 方法。接口中不需要先执行父类的 <code>&lt;clinit&gt;()</code> 方法，只有当父类中定义的变量被使用的时候，父类才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</p></li><li><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确地加锁、同步。</p></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>一个完整的 Java 程序是由许多的 <code>.class</code> 文件所组成的，在程序运行的过程中，只有这些 <code>.class</code> 文件加载进 JVM 中才可以被使用，而加载进虚拟机这个过程需要类加载器来完成。</p><p>Java 中的类加载器自带的有 3 中：</p><p><img src="http://baihonghua.cn/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A8%A1%E5%9E%8B.png"></p><p>通常情况下，.class 文件被主动加载进 JVM 的方式有：</p><ul><li><p>调用构造方法；</p></li><li><p>调用类中的静态方法或者静态属性；</p></li></ul><p>Java 中自带的类加载器分别有<strong>启动类加载器（Bootstrap ClassLoader）</strong>、<strong>扩展类加载器（ExtClassLoader）</strong>、<strong>应用类加载器（AppClassLoader）</strong>：</p><h5 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="# AppClassLoader"></a># AppClassLoader</h5><p>我们通过分析 <code>AppClassLoader</code> 的源码：</p><p><img src="http://baihonghua.cn/%E5%BA%94%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%BB%86%E8%8A%82.png"></p><p>从源码中可以知道，<code>java.class.path</code> 路径就是我们的环境配置 CLASS_PATH 路径，因而 <code>AppClassLoader</code> 加载的类是我们编写的类或者第三方 jar 包中的 <code>.class</code> 文件。</p><h5 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="# ExtClassLoader"></a># ExtClassLoader</h5><p>同样，我们通过分析 <code>ExtClassLoader</code> 源码：</p><p><img src="http://baihonghua.cn/ExClassLoader%E7%BB%86%E8%8A%82.png"></p><p>通过分析源码，我们可以知道，<code>ExtClassLoader</code> 是加载 <code>java.ext.dirs</code> 文件下的 <code>.class</code> 文件，我们可以通过打印分析 <code>ExtClassLoader</code> 类加载器具体加载的文件：</p><p><img src="http://baihonghua.cn/ExtClassLoader%E5%85%B7%E4%BD%93%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6.png"></p><h5 id="BootstrapClassLoader"><a href="#BootstrapClassLoader" class="headerlink" title="# BootstrapClassLoader"></a># BootstrapClassLoader</h5><p><code>BootstrapClassLoader</code> 类加载器和上面 <code>AppClassLoader</code>、<code>ExtClassLoader</code> 不同，<code>AppClassLoader</code>、<code>ExtClassLoader</code> 都是基于 Java 语言实现的类加载器，而 <code>BootstrapClassLoader</code> 则是基于 C/C++ 语言实现的。</p><p>在 Java 层无法直接获取 <code>BootstrapClassLoader</code> 的引用，如果尝试获取则返回 null。<code>BootstrapClassLoader</code> 加载系统属性 <code>sun.boot.classpath</code> 配置下的字节码文件，我们可以通过打印：</p><p><img src="http://baihonghua.cn/BootStrapClassLoader%E6%89%93%E5%8D%B0%E7%BB%86%E8%8A%82.png"></p><p>可以看出，<code>BootstrapClassLoader</code> 加载的是 jre 目录下的文件或 <code>.class</code> 文件。</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>在 Java 中既然已经有了 3 中类加载器，那么在加载 <code>.class</code> 文件的时候，虚拟机是如何知道选择哪一种类加载器进行加载的呢？答案就是接下来要说到的双亲委派模式了。</p><p><strong>所谓的双亲委派模式，就是在当类加载器接收到加载的任务的时候，首先把任务委托给父类进行加载，只有父类发现找不到资源或者找不到指定的类的时候，才自己执行实际的加载过程。</strong></p><p>我们可以在 <code>ClassLoader.java#loadClass(String, boolean)</code> 找到双亲委派模式的影子，代码如下：</p><p><img src="http://baihonghua.cn/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90.png"></p><p>逻辑说明：</p><ul><li><ol><li>先通过 <code>findLoadedClass(String)</code> 检查需要加载的字节码文件是否已经被加载，已经被加载则直接返回；</li></ol></li><li><ol start="2"><li>如果需要加载的字节码文件为空，即没有被加载，则检查自己的父类加载器是否为空，不为空的时候，通过调用父类的 <code>loadClass(String)</code> 进行加载；</li></ol></li><li><ol start="3"><li>如果父类为空，则通过 <code>findBootstrapClassOrNull(String)</code> 委托给启动类加载器加载；</li></ol></li><li><ol start="4"><li>如果启动类加载器找不到指定的类或找不到资源，就自己调用 <code>findClass(String)</code> 自己执行实际的加载；</li></ol></li></ul><p>那么，在上述的代码中，<code>parent</code> 所代表的的是什么呢？通过查看 <code>ClassLoader</code> 的构造方法：</p><p><img src="http://baihonghua.cn/classoloader%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png"></p><p>我们可以发现，<code>parent</code> 的确指代的是父类加载器，而我们通过翻阅源码可以发现，<code>AppClassLoader</code> 的父类加载器是 <code>ExtClassLoader</code>, 而 <code>ExtClassLoader</code> 的父类加载器为 null。</p><h5 id="举例说明"><a href="#举例说明" class="headerlink" title="# 举例说明"></a># 举例说明</h5><p><img src="http://baihonghua.cn/%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E_1.png"></p><p>通过上面双亲委派模式的理论可知，虚拟机首先会把类加载给 <code>AppClassLoader</code> 进行加载 <code>LearnClassLoad</code> 类。</p><ul><li><p><code>AppClassLoader</code> 首先会把加载任务委托其父类加载器 <code>ExtClassLoader</code> 进行加载；</p></li><li><p><code>ExtClassLoader</code> 同样也会把这加载任务委托给其父类，但发现自己的父类加载器为空，就把加载任务委托给 <code>BootstrapClassLoader</code> 进行加载；</p></li><li><p><code>BootstrapClassLoader</code> 在 <code>jdk\lib</code> 目录下无法找到 <code>LearnClassLoad</code>，因此返回的 Class 都为 null;</p></li><li><p>因为 <code>parent</code> 和 <code>BootstrapClassLoader</code> 都没有加载成功，所以只能通过调用自己的 <code>findClass</code> 去加载；</p></li></ul><p>最终 <code>LearnClassLoad</code> 是被 <code>AppClassLoader</code> 加载进虚拟机内存的，我们可以通过代码验证：</p><p><img src="http://baihonghua.cn/%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E_2.png"></p><p>有以上代码的打印结果，我们发现，<code>LearnClassLoad</code> 是被 <code>AppClassLoader</code> 加载进虚拟机内存的。</p><h5 id="注意"><a href="#注意" class="headerlink" title="# 注意"></a># <strong>注意</strong></h5><p>双亲委派机制只是 Java 推荐的类加载机制，并不是强制要求的。我们可以通过继承 <code>java.lang.ClassLoader</code> 来实现自己的类加载器。如果我们想保留双亲委派机制，我们可以重写 <code>findClass(String)</code> 方法，如果我们想要破坏双亲委派模型，我们可以重写 <code>loadClass(name)</code> 方法。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我主要从类加载进虚拟机的生命周期加载、连接（验证、准备、解析）、初始化来概述字节码加载进虚拟机的过程，以及详细地描述了 Java 的类加载器以及双亲委派模式，从而比较全面的描述了虚拟机的加载机制。但通过虚拟机的内存区域的划分、垃圾回收机制、以及虚拟机类加载机制的学习，才发现，这其实只是了解 Java 虚拟机的开始，深入学习 JVM 的路还很长很长…</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;虚拟机把描述的类的数据从 Class 文件加载进内存里面，同时对数据进行验证、解析、以及初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="https://hndroid.github.io/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="https://hndroid.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列-深入理解JVM垃圾回收</title>
    <link href="https://hndroid.github.io/2020/03/30/JVM%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://hndroid.github.io/2020/03/30/JVM%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2020-03-30T11:58:14.000Z</published>
    <updated>2021-06-20T11:52:16.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p> 在 Java 虚拟机中，一个 Java 对象被加载进 JVM 后，它的生命周期被划分为 7 个阶段：</p> <span id="more"></span><p> <img src="http://baihonghua.cn/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>如上图，对象的生命周期的 7 个阶段分别为：创建阶段、应用阶段、不可见阶段、不可达阶段、收集阶段、终结阶段、以及对象内存空间重新分配阶段。</p><ul><li>创建阶段</li></ul><p>创建阶段的步骤主要可以分为：</p><p>（1）为对象分配空间；<br>（2）构造对象；<br>（3）从超类到子类对 static 成员进行初始化;<br>（4）递归调用超类的构造方法；<br>（5）调用子类的构造方法；</p><ul><li>应用阶段</li></ul><p>当应用被初始化赋初值后，就切换进入应用阶段。这一阶段的对象至少具有一个强引用、或者显式地使用软引用、弱引用、或者虚引用；</p><ul><li>不可见阶段</li></ul><p>在应用程序中找不到对象的任何强引用，例如程序的执行已经超出了对象的作用域。但此时的对象仍然有可能被特殊的 GC Roots 所持有，例如对象被本地方法栈中的 JNI 引用或者被运行中的线程引用等；</p><ul><li>不可达阶段</li></ul><p>对象不被任何强引用所引用，并且垃圾收集器发现不可达；</p><ul><li>收集阶段</li></ul><p>垃圾收集器已经发现该对象不可达，并且垃圾收集器准备对该对象的内存空间重新分配。如果这时候垃圾收集器发现该对象重写了 <code>finalize()</code> 方法，垃圾收集器会豁免该对象的收集，并且调用 <code>finalize()</code> 方法。如果该对象没有重写 <code>finalize()</code> 方法，则等待垃圾收集器回收该对象的内存空间。</p><ul><li>终结阶段</li></ul><p>此时对象可能执行了 <code>finalize()</code> 方法（GC 不一定会等待该对象的 finalize() 方法执行完），或者该对象没有重写 <code>finalize()</code> 方法，这时候等待垃圾收集器收集该对象的内存空间。</p><ul><li>对象空间重新分配阶段</li></ul><p>当对象被 GC 回收了内存空间，该对象的生命周期就完全结束了。</p><p>以上，是一个对象被加载进 JVM 中的生命周期。而在 Java 虚拟机中，对象的回收对程序员是不可见的，也就是说一旦对象不被其他对象所引用，就有可能被 GC 标记为不可达，进而等待 GC 的回收。在 Java 虚拟机回收不被引用的对象的时候，会经历对象的标记、以及对象被垃圾收集器的回收过程。</p><h4 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h4><p>在 Java 虚拟机中，垃圾对象（当一个对象不被其他对象所持有的时候被称为垃圾对象）的标记算法，可以分为 <em><strong>引用计数法</strong></em> 和 <em><strong>可达性分析</strong></em> (也有部分文章把可达性分析称为根搜索算法) 。</p><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>在《深入理解 Java 虚拟机》一书中，给出的引用计数法的定义：给对象中添加一个引用计数器，每当有一个地方引用它时，引用计数器的值就会加 1；当引用失效的时候，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。但在目前主流的商用虚拟机中都没有采用引用计数法，原因是它很难解决对象之间互相引用的问题，如下代码：</p><p><img src="http://baihonghua.cn/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E8%AF%81%E6%98%8E_2.png" alt="引用计数算法证明_1"></p><p><img src="http://baihonghua.cn/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E8%AF%81%E6%98%8E_3.png" alt="引用计数算法证明_2"></p><p>如上代码，当执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TestReferenceCountingGC gc_1 = <span class="keyword">new</span> TestReferenceCountingGC();</span><br><span class="line">TestReferenceCountingGC gc_2 = <span class="keyword">new</span> TestReferenceCountingGC();</span><br><span class="line"></span><br><span class="line">gc_1.instance = gc_2;</span><br><span class="line">gc_2.instance = gc_1;</span><br></pre></td></tr></table></figure><p>的时候，由于 <code>new TestReferenceCountingGC()</code> 和 <code>new TestReferenceCountingGC()</code> 两个对象被引用了两次，如果根据引用计数算法，那么 <code>new TestReferenceCountingGC()</code> 和 <code>new TestReferenceCountingGC()</code> 的引用计数器的值都为 2。当执行 <code>gc_1 = null;</code> 和 <code>gc_2 = null;</code> 的时候，就会有 1 次引用失效，那么 <code>new TestReferenceCountingGC()</code> 和 <code>new TestReferenceCountingGC()</code> 还有 1 次引用，那么如果 Java 虚拟机采用的是引用计数算法标记垃圾对象，这两个对象的内存空间不会被垃圾收集器所回收，应该会出现如下 GC 日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 9339K-&gt;4872K(76288K)] 9339K-&gt;4880K(251392K), 0.0057164 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure><p>但是在实际中，却出现了如下的 GC 日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 9339K-&gt;776K(76288K)] 9339K-&gt;784K(251392K), 0.0015327 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br></pre></td></tr></table></figure><p>上述的 GC 日志证明目前的 Java 虚拟机的垃圾标记算法，并不是采用引用计数算法。</p><h5 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h5><p>可达性分析的主要思路就是通过一系列的称为 GC Roots 的对象作为起点，然后从这个节点往下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何的引用链相联（在图论中，就是从 GC Roots 到这个对象不可达）时，则证明这个对象时不用用的。</p><p><img src="http://baihonghua.cn/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png"></p><p>在 Java 中，可以作为 GC Root 的有以下几种（部分）：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中的静态属性引用的对象；</li><li>方法区中的 final 关键字修饰的常量引用的对象；</li><li>本地方法栈中 JNI 引用的对象；</li></ul><p>在 JDK 1.2 以前，引用的定义：在虚拟机栈的局部变量表中 reference 类型的数据中存储的数值代表的是另一种内存的起始地址，就称为这块内存代表着一个引用。但这种定义的说法只能用来定义被引用、和没有被引用这两种状态。为了可以描述这样的一类对象：当内存足够的时候，则保留在内存之中，如果内存空间在进行垃圾收集后，内存占用还是非常紧张，则可以回收这些对象。</p><p>于是，提出了强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phanton Reference）：</p><ul><li><p>强引用类似于 <code>Object obj = new Object()</code> 这类的引用，只要强引用存在，垃圾收集器永远不会回收这类对象；</p></li><li><p>软引用是一种相对于强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会回收软引用指向的对象。JVM 会确保在抛出 OOM 之前，清理软引用指向的对象；</p></li><li><p>弱引用并不能豁免垃圾收集，仅仅时提供访问在弱引用状态下对象的途径。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前的内存是否足够，都会回收掉只被弱引用关联的对象；</p></li><li><p>虚引用也被称为幽灵引用或者幻影引用，你不能通过它访问对象。虚引用仅仅时提供了一种确保对象在 <code>finalize()</code> 以后，做某些事情的机制，如能在对象被垃圾收集器回收时收到一个系统的通知。</p></li></ul><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>标记-清除算法分为两个阶段：</p><ul><li>标记阶段：标记可以被回收的对象；</li><li>清除阶段：回收被标记的对象内存；</li></ul><p>标记-清除算法时最基础的算法，因为后面提到的垃圾回收算法都是基于此算法的基础上面改造的，标记-清除算法的执行过程如下：</p><p><img src="http://baihonghua.cn/%E6%A0%87%E8%AE%B0.png"></p><p>标记-清除算法主要有两个缺点：一是标记和清除的效率都不高；二是如上图所示，在标记清除可回收的对象空间后，会产生大量不连续的内存碎片，碎片太多可能会导致后续没有足够的内存分配给较大的对象，从而导致触发新一轮的垃圾收集动作。</p><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决标记-清除算法带来的内存碎片的问题，于是提出了复制算法。复制算法把内存空间划分为大小相等的两块，每次只使用其中的一块，然后再把另一块内存空间清理掉：</p><p><img src="http://baihonghua.cn/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p><p>复制算法存在着复制效率低的不足，并且如果不想浪费 50% 空间内存，则需要提供额外的空间担保，以应对被使用的内存中所有的对象都 100% 存活的极端情况。</p><h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>复制算法一般不使用在老年代，因为在老年代中，大部分的对象的存活率比较高，选择复制算法就会导致过多的复制操作，导致效率变低。同时也不采用标记-清除算法，因为会产生过多的内存碎片，导致容易触发新的一轮垃圾回收动作。于是出现了一种标记-整理算法（标记-压缩算法）。标记-整理算法与标记-清除算法不同的是，在标记完内存中的对象以后，把存活下来的对象压缩到内存的一端，使得他们紧凑地排序在一起，然后对存活对象边界外的对象进行回收。</p><p><img src="http://baihonghua.cn/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"></p><h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><p>分代收集算法会结合不同的多种垃圾算法来处理不同的空间，因此在学习分代收集算法之前首先需要了解 Java 堆的空间划分。Java 堆被划分为新生代（Young Generation）和老年代（Tenured Generation），而新生代又被细分为 Eden 空间、From Survivor 空间和 To Survivor 空间。因为在 Java 堆里面，大部分对象都是”朝生夕灭”，只有少数的对象的生命周期比较长，甚至有的对象的生命周期和虚拟机的生命周期一样长，对不同对象地生命周期采用不同的垃圾收集算法，这就是分代收集的概念。</p><p>根据 Java 堆的空间的划分，垃圾收集最要可以分为两种方法：</p><ul><li>Minor GC: 新生代垃圾收集；</li><li>Full GC: 又称为 Major GC，Full GC 通常至少会伴随一次 Minor GC，它的收集频率较低，耗时较长。</li></ul><p>当执行一次 Minor GC 的时候，虚拟机会把 Eden 空间中存活的对象复制到 To Survivor 空间，同时把 From Survivor 空间存活的对象也复制到 To Survivor 空间，然后再把 Eden 空间和 From Survivor 空间里面的所有对象清除，这时候把 To Survivor 空间的指针指向 From Survivor 空间，也就是说 To Survivor 空间的名字变成了 From Survivor 空间，以等待下一次 Minor GC 的来临。当然，并不是所有的新对象都是分配在 Eden 空间的，当新对象需要占用的内存空间要比 Eden 空间可用的空间要大的时候，新对象会直接分配在老年代。</p><p>当对象在新生代经过一定数量的 Minor GC 后仍然存活，那么虚拟机会把该对象晋升到老年代中。虚拟机给每个对象都定义了一个对象年龄（Age）计数器。当新对象在 Eden 空间经过一次 Minor GC 仍然存活，并且可以被 Survivor 空间接纳，就把对象的年龄计数器设为 1，然后该对象每经过一次 Minor Gc，就把该对象的年龄计数器加 1，当对象的年龄计数器达到晋升老年代的阀值的时候，该对象就会晋升到老年代中，一般虚拟机设为 15。</p><p>当然，虚拟机也不一定需要对象的年龄计数器的值达到了晋升老年代的阀值来晋升对象的。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以进入老年代，而无需等到对象的年龄计数器的值满足晋升老年代的阀值。</p><p><img src="http://baihonghua.cn/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>原本还打算把内存的分配和回收策略、GC 日志分析也写在这里的，但瞄了瞄本章的篇幅，感觉有点篇幅过长了，哈哈哈…那….我就不写啦。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt; 在 Java 虚拟机中，一个 Java 对象被加载进 JVM 后，它的生命周期被划分为 7 个阶段：&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="https://hndroid.github.io/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="https://hndroid.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列-深入理解JVM内存区域</title>
    <link href="https://hndroid.github.io/2020/03/23/JVM%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>https://hndroid.github.io/2020/03/23/JVM%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-03-23T04:38:20.000Z</published>
    <updated>2021-06-20T11:52:16.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Java 的 <code>.class</code> 文件通过类加载器加载进虚拟机内存里面，由 JVM 虚拟机通过解析执行、或编译执行。JVM 为了方便管理被加载进来的 <code>.class</code> 内容，提出了 Java 虚拟机运行时数据区的概念。Java 虚拟机运行时数据区可以划分为线程私有、线程共享两大类型的数据区，其中线程私有包括程序计数器、虚拟机栈、本地方法栈；而线程共享包括 Java 堆、方法区。</p><span id="more"></span><p><img src="http://baihonghua.cn/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png"></p><p>在没有深入理解 JVM 之前，我们常常会把 Java 运行时数据区粗粒度地划分为 “堆”、”栈” 两大部分，”堆” 是用来存放对象地实例，而 “栈” 则是用来存放对象地引用。随着我们对 JVM 地深入学习，我们发现 JVM 对内存的划分远比我们在学习 Java 初级阶段所认知的运行时数据区要复杂。C/C++ 的程序员需要手动释放程序里面不需要再用到的内存空间，而在 Java 里面，虚拟机会自动地帮我们回收不需要用到的资源，这就需要我们深入理解 JVM 运行时的内存划分，有利于我们对程序有更加深刻的认识。</p><h4 id="数据区详解"><a href="#数据区详解" class="headerlink" title="数据区详解"></a>数据区详解</h4><p><img src="http://baihonghua.cn/%E5%85%B7%E4%BD%93%E7%9A%84Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块比较小的数据区域。因为在 Java 中是支持多线程的，那就意味着每条线程内需要一块内存空间，记录当前线程切换的时候（现场销毁），当前字节码执行的行号数，以便在该线程重新获取到 CPU 执行时间的时候，可以接着上次执行的字节码行数号继续执行（现场恢复）。而程序计数器则是为了记录当前线程的字节码执行的行数号而提出的。</p><p>字节码的解析器是根据该计数器的值来选取下一条需要解析执行的字节码指令。Java 代码的循环、跳转、异常处理、线程恢复等都需要依靠该计数器来完成。</p><p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 native 方法，这个计数器的值则为空（Undefined）。程序计数器是 JVM 唯一一个没有规定任何 OOM 情况的区域。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：在 Java 中每执行一个方法都会创建一个栈帧，然后系统会把这个栈帧压入虚拟机栈。栈帧还可以划分为局部变量表、操作数栈、动态链接、方法出口（方法返回地址）、以及额外的附加信息。Java 方法的执行就对应着栈帧在虚拟机中入栈和出栈的过程。</p><ul><li><p>局部变量表主要存放的是方法在执行过程中的局部变量。如在方法中定义的八种基本类型、局部的变量等。</p></li><li><p>操作数栈存放的是操作数。操作数栈是一个栈结构的数据结构，栈元素可以为任意的 Java 数据类型。一个方法刚开始分配栈帧空间执行的时候，操作数栈是空的，当在执行方法内局部变量的运算的时候，操作数栈便会执行进栈/出栈操作。</p></li><li><p>动态链接的作用主要是支持 Java 语言的多态性（需要类加载、运行时才能确定的方法）、动态性。</p></li><li><p>方法返回地址返回的是方法结果的返回。如果是正常返回，则调用程序计数器中的地址作为返回；如果是异常返回，则是通过异常处理器表（非栈帧中的）来确定。</p></li></ul><p>同时，Java 虚拟机规范中定义了虚拟机栈有两种异常：</p><table><thead><tr><th align="left">异常</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left">StackOverFlowError</td><td align="left">当虚拟机请求的栈深度超过当前栈帧所一开始定义的栈帧深度时抛出</td></tr><tr><td align="left">OutOfMemoryError</td><td align="left">如果虚拟机可以在运行时动态申请栈内存空间，当 Java 虚拟机无法申请到更多的栈内存的时候抛出</td></tr></tbody></table><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用时比较相似的，只不过虚拟机栈为 Java 的普通方法提供内存空间，而本地方法栈则为 Java 的本地方法提供内存空间。因此，有的虚拟机如 Sun HotSpot 虚拟机就直接地把虚拟机栈和本地方法栈合二为一。</p><p>同时，本地方法栈和虚拟机栈一样，也会抛出 <code>StackOverFlowError</code>、<code>OutOfMemoryError</code> 两种异常。</p><h4 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h4><p>Java 堆是虚拟机中最大地一块内存空间，同时该内存区域也是每条线程可以共享的。Java 堆是在虚拟机创建的时候创建的，其主要的目的使用来存放对象实例、数组数据。但随着 JIT编译器的发展、逃逸分析技术的发展，使得对象可以在栈中分配。</p><p>Java 堆是 GC 垃圾回收的主要区域。从内存回收的角度，因为 Java 堆主要采取分代收集算法，因而 Java 堆可以划分为新生代、老年代，而新生代又可以划分为 Eden空间、From Survivor和 To Survice空间。</p><p><img src="http://baihonghua.cn/Java%E5%A0%86.png"></p><p>从内存共享的角度，Java 堆可以被划分为多个线程共享的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p><p>根据虚拟机规范，Java 堆可以是物理内存上不连续，而在逻辑上连续的。同时，堆在无法完成实力的分配，并且虚拟机无法申请到更多的堆内存的时候，会抛出 <code>OutOfMemoryError</code> 异常。</p><p>在虚拟机中，对象实例主要是分配 Java 堆中，对象实例在内存的布局如下：</p><p><img src="http://baihonghua.cn/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></p><p>对象实例的内存布局分为 3 块区域：对象头（Header）、实例数据（Instance）、对齐填充（Padding）。</p><ul><li><p>对象头（Header）在 HotSpot 中包括两部分信息：用于存储对象自身的运行时数据、类型指针。对于第一部分用于存储自身运行时数据如上图；而对于第二部分类型指针，即对象指向它的元数据的指针，虚拟机通过这个指针来确定这个对象它属于哪一个类的实例。但并不是所有的虚拟机都需要在对象头数据上面保留类型指针，因为查找对象的元数据不一定需要通过对象的本身（如反射）。</p></li><li><p>实例数据部分是对象真正存储的有效信息的，如在 Java 源码中所定义的各种类型的字段内容，包括从父类继承的数据内容。同时在实例数据部分的存储收到虚拟机的分配策略（FieldsAllocationStyle）和字段在 Java 源码中顺序的影响。</p></li><li><p>对齐填充并不是必然存在对象实例布局中的，其没有特别的含义。因为虚拟机的自动内存管理系统要求对象的大小必须需要 8 字节的整数倍。对象头大小刚好是 8 字节的倍数（1 倍或 2 倍），当实例数据没有对齐的时，就需要对齐填充来补全。</p></li></ul><p>在 Java 堆中存放对象的实例的目的是为了访问使用对象，Java 程序需要通过虚拟机栈上本地变量表上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。</p><p>同时，该 Java 堆可以抛出 <code>OutOfMemoryError</code> 异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据，GC 在该区域出现的比较少。同时，该方法区还包含着运行时常量池。</p><p>运行时常量池用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><ul><li><p>各种字面量与 Java 语言层面概念相近，包含文本字符串、声明为 final 的常量等；</p></li><li><p>符号引用包括：类和接口的全限定名称、字段的名称和描述符、方法的名称和描述符；</p></li></ul><p>同时，方法区也可以抛出 <code>OutOfMemoryError</code> 异常。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上，包含了 JVM 运行时为 Java 的 <code>.class</code> 加载进 JVM 所划分的区域，分别为线程私有和线程共享的区域。当然，这只是深入理解 JVM 的过程的一小步，接下来还需要了解 JVM 对 Java 堆的垃圾标记、以及垃圾收集……</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Java 的 &lt;code&gt;.class&lt;/code&gt; 文件通过类加载器加载进虚拟机内存里面，由 JVM 虚拟机通过解析执行、或编译执行。JVM 为了方便管理被加载进来的 &lt;code&gt;.class&lt;/code&gt; 内容，提出了 Java 虚拟机运行时数据区的概念。Java 虚拟机运行时数据区可以划分为线程私有、线程共享两大类型的数据区，其中线程私有包括程序计数器、虚拟机栈、本地方法栈；而线程共享包括 Java 堆、方法区。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="https://hndroid.github.io/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="https://hndroid.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>动态代理原理分析</title>
    <link href="https://hndroid.github.io/2020/03/19/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://hndroid.github.io/2020/03/19/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2020-03-19T02:38:48.000Z</published>
    <updated>2021-06-20T11:52:16.145Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>代理模式（Proxy design pattern）可以分为静态代理和动态代理，两种代理模式本质都是对外隔离真实的业务类，并且对外通过代理类，引入代理类的附加功能。对于动态代理的理解，其动态性并不是表现在省去了编写代理类的代码的工作量，而是表现在当真实的业务类、接口类还未知的时候，就可以确定了代理类的行为。</p><span id="more"></span><p><img src="http://baihonghua.cn/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png"></p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IFractory 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFractory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyFractory</span> <span class="keyword">implements</span> <span class="title">IFractory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产玩具的厂家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IFractory mIFractory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IFractory <span class="title">getIFractory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mIFractory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIFractory</span><span class="params">(IFractory pIFractory)</span> </span>&#123;</span><br><span class="line">        mIFractory = pIFractory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(mIFractory.getClass().getClassLoader(),</span><br><span class="line">                mIFractory.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);  <span class="comment">// 注释 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object lInvoke = method.invoke(mIFractory, args);</span><br><span class="line">        <span class="keyword">return</span> lInvoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDynamicProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ToyFractory lToyFractory = <span class="keyword">new</span> ToyFractory();</span><br><span class="line">        DynamicProxy lDynamicProxy = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line">        lDynamicProxy.setIFractory(lToyFractory);</span><br><span class="line"></span><br><span class="line">        IFractory lProxyInstance = (IFractory) lDynamicProxy.createProxyInstance();</span><br><span class="line"></span><br><span class="line">        lProxyInstance.createProduct();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码简单创建了 <code>DynamicProxy</code> 类继承了 <code>InvocationHandler</code> 类，并重写 <code>InvocationHandler#invoke()</code> 方法，然后在 <code>TestDynamicProxy</code> 类中创建真正的业务类，并通过 <code>lDynamicProxy#createProxyInstance()</code>生成代理类对象，代理类对象通过调用 createProduct() 方法，间接地调用真正的业务类的真实业务，如上述代码。</p><p>我们需要分析动态代理是如何为我们创建代理（Proxy）类的，我们查看[注释 1 ]处的代码细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proxy.java#newProxyInstance()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆出一份class&lt;?&gt;[] 数组，避免后续的操作干扰到 interfaces数组；（Java 语言是值传递）</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 注释 2</span></span><br><span class="line">    <span class="comment">// 根据参数生成指定的代理类对象</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过反射调用，生成代理类对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法 <code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 主要的作用是根据指定的接口返回对应的代理类对象。</p><p>在上面的 <code>Proxy#newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 方法中，我去掉了一些不重要的代码逻辑，这个方法主要的作用是通过 <code>Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 生成一个代理类的 Class 类，然后通过反射运行时获取到该代理类的实例，具体代码如上。</p><p>在 [注释 2]处，通过查看 <code>Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 方法的具体实现，可以发现返回的 Class 代理类是通过给定的类加载器、指定的类接口而生成的，在程序运行期间会存储在内存中，在再次需要的时候，直接返回，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* a cache of proxy classes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">    proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class="line"><span class="comment">* to perform permission checks before calling this.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 接口数量不可以超过 65535                                       </span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="comment">// 注释 3</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过解读上面 <code>Proxy#getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 的注释，可以知道：如果代理类的 Class 存在，则直接从内存中把 Class 返回，如果代理类不存在通过则通过 <code>ProxyClassFactory</code> 创建代理类。</p><p>那么，这时候我们心里面会有疑问，<code>ProxyClassFactory</code> 是如何创建代理类 Class 的呢？</p><p>带着疑问，我们继续沿着代码往下面读。通过查阅代码，我们发现 [注释 3] 处的 <code>proxyClassCache</code> 变量是 <code>WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</code> 类型的，并且通过 <code>new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory())</code> 初始化了该变量，并在初始化的同时，发现 <code>ProxyClassFactory</code> 这个创建代理类的重要参数，传入 <code>WeakCache</code> 构造方法的第二个参数，那么我们在往下阅读的时候，需要额外关注 <code>WeakCache</code> 的构造方法的第二个参数。通过阅读 <code>WeakCache#get(K key, P parameter)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">        <span class="comment">// map 是 ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; 类型的</span></span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">                = map.putIfAbsent(cacheKey,</span><br><span class="line">                                  valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">            <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                valuesMap = oldValuesMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line">        <span class="comment">// subKey from valuesMap</span></span><br><span class="line">        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">                <span class="comment">// 注释 4</span></span><br><span class="line">                V value = supplier.get();</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else no supplier in cache</span></span><br><span class="line">            <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">            <span class="comment">// or a Factory that wasn&#x27;t successful in installing the CacheValue)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// lazily construct a Factory</span></span><br><span class="line">            <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">                factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">                <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// successfully installed Factory</span></span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else retry with winning supplier</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                    <span class="comment">// successfully replaced</span></span><br><span class="line">                    <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                    <span class="comment">// with our Factory</span></span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// retry with current supplier</span></span><br><span class="line">                    supplier = valuesMap.get(subKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>WeakCache#get(K key, P parameter)</code> 的方法逻辑比较复杂，但比较重要的是在 [注释 4] 处，代码 <code>supplier.get()</code> 中， 可以通过代码知道，<code>supplier</code> 是通过 <code>new Factory(key, parameter, subKey, valuesMap)</code> 初始化的，因此我们可以阅读 <code>Factory#get()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Factory(K key, P parameter, Object subKey,</span><br><span class="line">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.parameter = parameter;</span><br><span class="line">        <span class="keyword">this</span>.subKey = subKey;</span><br><span class="line">        <span class="keyword">this</span>.valuesMap = valuesMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">        <span class="comment">// re-check</span></span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// something changed while we were waiting:</span></span><br><span class="line">            <span class="comment">// might be that we were replaced by a CacheValue</span></span><br><span class="line">            <span class="comment">// or were removed because of failure -&gt;</span></span><br><span class="line">            <span class="comment">// return null to signal WeakCache.get() to retry</span></span><br><span class="line">            <span class="comment">// the loop</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else still us (supplier == this)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// create new value</span></span><br><span class="line">        V value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注释 5</span></span><br><span class="line">            value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">                valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the only path to reach here is with non-null value</span></span><br><span class="line">        <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wrap value with CacheValue (WeakReference)</span></span><br><span class="line">        <span class="comment">// 把创建出的代理类 Class 存储在 CacheValue</span></span><br><span class="line">        CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put into reverseMap</span></span><br><span class="line">        <span class="comment">// cacheValue 继续放进 reverseMap 里面；</span></span><br><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">        <span class="comment">// wrapped by it</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读代码，我们可以发现 <code>Factory</code> 是 <code>WeakCache</code> 的普通内部类。<code>Factory</code> 类的代码逻辑比较简单，我们主要看 [注释 5] 处，代码 <code>valueFactory.apply(key, parameter)</code> 返回的值，正是我们需要的代理类 Class 对象，那么 <code>valueFactory</code> 是什么呢？</p><p>通过再次阅读代码，我们可以发现，<code>valueFactory</code> 正是源码中 <code>new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory())</code> 的第二个参数 <code>new ProxyClassFactory()</code>, 那么我们可以尝试推断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; proxy = proxyClassCache.get(loader, interfaces);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Class&lt;?&gt; proxy = <span class="keyword">new</span> ProxyClassFactory().apply(loader, interfaces);</span><br></pre></td></tr></table></figure><p>当然，上面的等价只是抽离了很多相关的代码而推断出的结论，实际上并不可以编译的。那么我们现在只需要专注于 <code>ProxyClassFactory#apply(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code> 方法，通过下面阅读源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">        * interface to the same Class object.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 验证类加载器是否将此接口的名称解析为同一Class对象</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类的包路径</span></span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">    * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">    * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 数字类加操作，从数字 0 开始（原子操作）</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    <span class="comment">// 拼接代理类的名字，如 $Proxy0 ...</span></span><br><span class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 生成指定的代理类，这里是一个 byte 类型的数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">        proxyName, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注释 6</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                            proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">            * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">            * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">            * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">            * exceeded).</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们继续阅读 <code>private static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len)</code> 方法的时候，发现其是一个本地方法，底层如何实现我们在这里就不深究了（主要是我懒）。</p><p>在 <code>ProxyClassFactory#apply(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code> 方法中，主要是准备创建 Proxy 代理类的准备工作，并没有太多复杂难懂的代码。</p><p>那么 <code>proxyClassFile</code> 内容是怎样的呢？我们可以通过输入输出流，把 <code>proxyClassFile</code> 输出到 <code>.class</code> 类型的文件中，文件代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.xxx.proxy_2.IFractory;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">IFractory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注释 7</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;cn.enjoyedu.proxy_2.IFractory&quot;</span>).getMethod(<span class="string">&quot;createProduct&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读生成的 <code>$proxy0.class</code> 源码，我们可以主要阅读 [注释 7] 处，<code>super.h.invoke(this, m3, new Object[]&#123;var1&#125;)</code> 中，<code>h</code>表示的是 <code>Proxy#InvocationHandler</code>, 那么我们就可以得出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler#invoke(</span><br><span class="line">    <span class="keyword">new</span> Proxy(),</span><br><span class="line">    Class.forName(<span class="string">&quot;cn.xxx.proxy_2.IFractory&quot;</span>).getMethod(<span class="string">&quot;saleManTools&quot;</span>, Class.forName(<span class="string">&quot;java.lang.String&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Object[]&#123;var1&#125;)</span><br></pre></td></tr></table></figure><p>以上，是动态代理源码分析的主要内容，知道动态代理主要是通过代码在内存中，生成指定类加载器和类接口的代理对象，然后保存在内存中，在需要的时候返回指定的代理实例。</p><p>通过上述的代码分析，我们也可以知道，动态代理会占用一定的内存，而且效率相对于静态代理较低，但这样子避免了在未确定真实类、以及对应的接口的时候，就可以确定代理类的行为，从而可以分离代理类和真实业务类的耦合，可以很灵活地应用在不同的场景中。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;代理模式（Proxy design pattern）可以分为静态代理和动态代理，两种代理模式本质都是对外隔离真实的业务类，并且对外通过代理类，引入代理类的附加功能。对于动态代理的理解，其动态性并不是表现在省去了编写代理类的代码的工作量，而是表现在当真实的业务类、接口类还未知的时候，就可以确定了代理类的行为。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://hndroid.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://hndroid.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>App黑白屏启动优化</title>
    <link href="https://hndroid.github.io/2020/01/04/App%E9%BB%91%E7%99%BD%E5%B1%8F%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://hndroid.github.io/2020/01/04/App%E9%BB%91%E7%99%BD%E5%B1%8F%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2020-01-04T08:36:37.000Z</published>
    <updated>2021-06-20T11:52:16.128Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开机启动流程概述"><a href="#开机启动流程概述" class="headerlink" title="开机启动流程概述"></a>开机启动流程概述</h4><p> Linux 操作系统从开机加电到执行 main 函数的执行可以分三步完成，其目的是实现从启动盘加载操作操作系统程序，完成执行 main 函数所需要的准备工作。第一步，启动 BIOS，准备实模式下的中断向量表和中断服务程序；第二步，从启动盘加载操作系统程序到内存，加载操作系统程序的工作就是利用第一步准备的中断服务程序实现的；第三步，为执行 32 位的 main 函数做过度工作。</p> <span id="more"></span><p> Android 操作系统是基于 Linux Kernel 实现的。Android 从开机加电的时候，首先会启动 BootLoader 这个引导程序，通过这个引导程序启动 <code>Linux Kernel</code>，这时候会给操作系统分配内存、以及加载操作系统所需要的驱动。然后通过找到 <code>init.rc</code> 这个文件，首先启动 init 进程，并且 init 进程的 id 为 1。在 init 进程启动以后，init 进程会去启动 zygote 进程，而 zygote 进程会去启动 JVM、<code>SystemServer</code> 等关键的服务。然后 <code>SystemServer</code> 会去启动 Binder线程池、<code>SystemServiceManager</code>、<code>ActivityManagerService</code>等其他各种服务。再然后由 <code>ActivityManagerService</code> 去启动 Launcher APP。</p><p> <img src="http://baihonghua.cn/App%E5%90%AF%E5%8A%A8.png"></p><h4 id="APP的冷、热、暖启动"><a href="#APP的冷、热、暖启动" class="headerlink" title="APP的冷、热、暖启动"></a>APP的冷、热、暖启动</h4><table><thead><tr><th align="left">方式</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left">冷启动</td><td align="left">程序从头开始，系统没有为该程序创建进程。一般场景：程序安装后的第一次启动、或者应用程序被系统完全终止后再打开。</td></tr><tr><td align="left">热启动</td><td align="left">此时程序仍然驻留在内存中，只是被系统从后台带到前台，因此程序可以避免重复对象初始化，加载布局和渲染。需要注意的是，如果程序的某些内存被系统清除，比如调用了 <code>onTrimMemory</code> 方法，则需要重新创建这些对象以响应热启动事件。</td></tr><tr><td align="left">暖启动</td><td align="left">它包含热启动和冷启动一系列的操作子集，比热启动的消耗稍微多一点。它与热启动最大的区别在于，它必须通过调用 onCreate 方法开始重新创建活动，也可以从传传递给 onCreate 方法中保存的实例状态中获得某些对象的恢复。</td></tr></tbody></table><h4 id="冷启动流程"><a href="#冷启动流程" class="headerlink" title="冷启动流程"></a>冷启动流程</h4><ul><li>加载并启动 APP；</li><li>启动后立即为该 APP 显示一个空白启动窗口；</li><li>创建 APP 进程；（创建应用程序对象）</li><li>创建主 Activity；</li><li>加载布局，绘制；</li></ul><h4 id="APP启动总结"><a href="#APP启动总结" class="headerlink" title="APP启动总结"></a>APP启动总结</h4><p> APP 从被系统调用，再到第一个页面渲染到手机屏幕。我们通常只需要关注 Application 中的 onCreate 方法，第一个 Activity 中 onCreate、onStart、onResume 方法；</p><p> 注意：如果在 APP 启动第一个 Activity 时，该 Activity 不但有自己的逻辑，还在 onCreate、onStart、或者 onResume 方法中直接又跳转到了其他 Activity 页面，那么跳转后的 Activity 方法也需要进行优化；</p><h4 id="黑白屏原因"><a href="#黑白屏原因" class="headerlink" title="黑白屏原因"></a>黑白屏原因</h4><p> 根据前面的冷启动流程，我们知道当系统加载并且启动 App 的时候，需要耗费相应的时间，即使时间不到 1s，用户也会感觉到当点击 App 图标时会有 “延迟” 现象，为了解决这一个问题，Google 的做法是在 App 创建的过程中，先展示一个空白页面，让用户体会到点击图标以后立马就有响应；而这个空白页面的颜色则是根据我们在 Manifest 文件中配置的主题颜色来决定的；一般默认为白色；</p><h4 id="解决黑白屏以及App启动优化"><a href="#解决黑白屏以及App启动优化" class="headerlink" title="解决黑白屏以及App启动优化"></a>解决黑白屏以及App启动优化</h4><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p><img src="http://baihonghua.cn/%E9%BB%91%E7%99%BD%E5%B1%8F%E4%BC%98%E5%8C%96.png"></p><p>如上图，通过修改 AppTheme 的方式。即在应用默认的 AppTheme 中，设置 <code>android:windowDisablePreview</code> (系统取消预览空白窗体) 为 true，或者通过设置空白窗体为透明；</p><p>则两种方式属于同一种方案：将 Theme 的背景改为透明，这样用户从视图上就无法看出黑白屏的存在；</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p><img src="http://baihonghua.cn/%E9%BB%91%E7%99%BD%E5%B1%8F%E5%90%AF%E5%8A%A8.png"></p><p>第二种黑白屏的解决方案是自定义继承自 AppThemme 的主题，然后将启动的 Activity 的 theme 设置为自定义的主题，然后在启动的 Activity 的 onCreate 和 setContentView 方法之前调用 setTheme 方法，将主题设置为最初的 AppTheme；</p><p>方案二实现的效果类似于网易云音乐 App 启动的效果；</p><p>方案二实现的原理：主要是优化 App 启动时候的空白窗体，而不是像方案一那样子直接把 App 启动时候的黑白窗体取消、或者变透明的处理方案，方案二的方式更加贴近 Google 官方提供的处理方案，便于后续的启动页面的优化；</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;开机启动流程概述&quot;&gt;&lt;a href=&quot;#开机启动流程概述&quot; class=&quot;headerlink&quot; title=&quot;开机启动流程概述&quot;&gt;&lt;/a&gt;开机启动流程概述&lt;/h4&gt;&lt;p&gt; Linux 操作系统从开机加电到执行 main 函数的执行可以分三步完成，其目的是实现从启动盘加载操作操作系统程序，完成执行 main 函数所需要的准备工作。第一步，启动 BIOS，准备实模式下的中断向量表和中断服务程序；第二步，从启动盘加载操作系统程序到内存，加载操作系统程序的工作就是利用第一步准备的中断服务程序实现的；第三步，为执行 32 位的 main 函数做过度工作。&lt;/p&gt;</summary>
    
    
    
    <category term="性能优化" scheme="https://hndroid.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://hndroid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android进程间通信（IPC）机制Binder系列笔记（三）</title>
    <link href="https://hndroid.github.io/2019/11/25/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E6%9C%BA%E5%88%B6Binder%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://hndroid.github.io/2019/11/25/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E6%9C%BA%E5%88%B6Binder%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2019-11-25T03:38:52.000Z</published>
    <updated>2021-06-20T11:52:16.127Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Binder 是 Android 开发者阅读 Android 源码、Linux Kernel 层源码的时候，必须要弄懂的一个知识点。Binder 它出现在 Android Driver 层、Android Native 层、Android Framework 层，当然，在 Android 的 App 层使用的 Binder 框架，也是需要依赖以上三层才可以实现的。</p><span id="more"></span><h4 id="Binder-在不同角度上的定义"><a href="#Binder-在不同角度上的定义" class="headerlink" title="Binder 在不同角度上的定义"></a>Binder 在不同角度上的定义</h4><ul><li><p>IPC：Binder 是 Android 系统中的一种基于 C/S（Client/Server）、全双工的一种跨进程通信方式，该通信方式在 Linux 系统中是没有，是 Android 系统独有的；</p></li><li><p>Android Driver：Binder 可以理解为一种虚拟的物理设备，它的设备驱动是 /dev/binder。在 Linux 系统中，一切皆文件。驱动层位于 Linux Kernel 中，它提供了最底层的数据传递、对象标识、线程管理、调用过程控制等功能。驱动层是整个 Binder 机制的核心；</p></li><li><p>Android Native：Binder 是创建 Service Manager 以及 BpBinder/BBinder 模型，搭建与 Binder 驱动的桥梁；</p></li><li><p>Android Framework：Binder 是各种 Manager（ActivityManager、WindowManager 等）和相应的 xxxManagerService 的桥梁；</p></li><li><p>APP：Binder 是客户端和服务端进行通信的媒介，当调用 bindService 的时候，服务端会返回一个包含了服务端业务方法调用的 Binder 对象，通过这个 binder 对象，客户端就可以调用服务端的 Binder 对象，去获取服务端提供的服务或者数据，这里的服务包含普通服务和基于 AIDL（Android Interface Define Language）的服务；</p></li></ul><h4 id="BpBinder-BBinder-模型"><a href="#BpBinder-BBinder-模型" class="headerlink" title="BpBinder/BBinder 模型"></a>BpBinder/BBinder 模型</h4><p>在上面的 Android Native 层，我们提及到了 BpBinder/BBinder 模型 。BpBinder/BBinder 是 Binder 通信的的 “双子星”，都是实现了 IBinder 接口，表示具有跨进程的能力。BpBinder 是 Client 端与 Service 交互的代理类，而 BBinder 则代理了 Service 端。BpBinder 和 BBinder 是一一对应的，BpBinder 通过 Hander 找到对应的 BBinder。在 ServiceManager 中创建了 BpBinder，通过 Handler（值为0）可以找到对应的 BBinder。</p><p><img src="http://baihonghua.cn/BpBinder%E5%92%8CBBinder.png"></p><h4 id="Binder-驱动源码分析"><a href="#Binder-驱动源码分析" class="headerlink" title="Binder 驱动源码分析"></a>Binder 驱动源码分析</h4><ul><li><p><code>binder_init()</code> 函数主要是驱动设备的初始化；</p></li><li><p><code>binder_open()</code> 函数是打开 Binder 驱动设备；</p></li><li><p><code>binder_mmap()</code> 该函数是 Binder 的内存地址映射函数。首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存块。然后再申请 1 个 page 大小的物理内存，再将同一块物理内存分别映射到内核虚拟地址和用户虚拟内存空间，从而实现了用户空间的 Buffer 和内核空间的 Buffer 同步操作的功能。</p></li><li><p><code>binder_ioctl()</code> 该函数主要是用于数据操作；</p></li></ul><p>Binder 再进程中进行数据通信的时候，Client 端向 Server 端发送数据时，Client 先从自己的进程空间把 IPC 通信数据 copy_from_user 拷贝到内核空间，而 Server 端与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量，即可以获取到对应的内核空间的地址，整个过程只发生一次内存的拷贝；</p><h4 id="ServiceManager-源码分析"><a href="#ServiceManager-源码分析" class="headerlink" title="ServiceManager 源码分析"></a>ServiceManager 源码分析</h4><p>ServiceManager 位于 Android Native 层的 <code>/frameworks/native/cmds/servicemanager/service_manager.c</code>，调用的是 Kernel 层的 <code>binder.c</code> 驱动。<br><img src="http://baihonghua.cn/service_manager_main%28%29.png"><br>获取 Service Manager 是通过调用 <code>defaultServiceManager()</code> 方法来完成，当进程注册服务 <code>addService</code> 或获取服务 <code>getService</code> 的过程之前，都需要通过调用 <code>defaultServiceManager()</code> 方法来获取 <code>gDefaultServiceManager</code> 对象。对于 <code>gDefaultServiceManager</code> 对象，如果存在则直接返回；如果不存在则创建该对象，创建过程包括调用 <code>open()</code> 打开 <code>binder</code> 驱动设备，利用 <code>mmap()</code> 映射内核的地址空间; 并通过 <code>do_add_service()</code> 注册服务、<code>do_find_service()</code> 查询服务</p><h4 id="framework-层源码分析"><a href="#framework-层源码分析" class="headerlink" title="framework 层源码分析"></a>framework 层源码分析</h4><ul><li><p>注册 Binder：建立了 Binder 类在 Native 层与 Framework 层之间的相互调用的桥梁；</p></li><li><p>注册 BinderInternal：建立了 BinderInternal 类在 Native 层与 Framework 层之间的相互调用的桥梁；</p></li><li><p>注册BinderProxy：建立了 BinderProxy 类在 Native 层与 Framework 层之间的相互调用的桥梁；</p></li></ul><h4 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h4><p>这次主要是就 Binder 的底层的驱动初始化、Binder 底层驱动如何被上层调用的流程做了一个宏观的描述。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Binder 是 Android 开发者阅读 Android 源码、Linux Kernel 层源码的时候，必须要弄懂的一个知识点。Binder 它出现在 Android Driver 层、Android Native 层、Android Framework 层，当然，在 Android 的 App 层使用的 Binder 框架，也是需要依赖以上三层才可以实现的。&lt;/p&gt;</summary>
    
    
    
    <category term="Android进阶" scheme="https://hndroid.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Android" scheme="https://hndroid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android进程间通信（IPC）机制Binder系列笔记（二）</title>
    <link href="https://hndroid.github.io/2019/11/25/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E6%9C%BA%E5%88%B6Binder%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://hndroid.github.io/2019/11/25/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E6%9C%BA%E5%88%B6Binder%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2019-11-25T03:38:37.000Z</published>
    <updated>2021-06-20T11:52:16.128Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Binder-在不同的角度上的定义"><a href="#Binder-在不同的角度上的定义" class="headerlink" title="Binder 在不同的角度上的定义"></a>Binder 在不同的角度上的定义</h4><ul><li>从设备的角度来说，Binder 是一种虚拟的物理设备驱动，位于 /dev/binder 目录下；</li><li>从 Android 的代码上来说，Binder 是 Android 中的一个类，实现了 IBinder 接口；</li><li>从 IPC 角度来说，Binder 是 Android 中的的一种跨进程的通信方式，在 Linux 系统上没有；</li><li>从Android Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager 和相应的 ManagerService 的桥梁；</li><li>从 Android 应用层来说，Binder 是 client 和 service 进行通信的媒介，当 bindService() 的时候，service端会返回一个包含 service 端业务调用的 Binder 对象，通过这个 Binder 对象，client 端就可以获取到 service 端提供的服务或者数据了；</li></ul><span id="more"></span><h4 id="Android-采用-Binder-的原因"><a href="#Android-采用-Binder-的原因" class="headerlink" title="Android 采用 Binder 的原因"></a>Android 采用 Binder 的原因</h4><blockquote><p>在讨论 Android 采用 Binder 的原因之前，需要知道为什么会出现 IPC/RPC 的通信方式</p></blockquote><h5 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h5><blockquote><p>进程隔离是为了保护操作系统中进程中进程互不干扰而设计的一组不同硬件而软件的技术。这个技术是为了避免进程 A 写入进程 B 的情况发生的。进程的隔离实现，使用了虚拟地址的空间。进程 A 的虚拟地址和进程 B 的虚拟地址不同，这是为了防止进程 A 将数据信息写入进程 B。</p></blockquote><p>这也就意味着，进程中的数据是不共享的，A 进程无法直接访问到 B 进程的数据，以此来保证数据的安全。</p><p>在进程隔离的系统中，两个不同的进程需要进行通信，就必须通过 IPC 来实现。</p><p>Android 是基于 Linux 系统上的，理论上应当采用 Linux 系统的 IPC 通信方式。Linux 系统中的 IPC 方式共有 5 中，大体划分为三种 socket、管道、共享内存。而 Android 并没有采用 Linux 中的 IPC 方式，而采用称为 Binder 的 IPC 方式。</p><p>Binder 是一种基于 Client-Service 通行模式的通信方式，传输过程只需要一次拷贝，可以为发送方添加 UID/PID 标记，支持实名 Binder 和匿名 Binder，安全性高；</p><p>下表描述 Linux 中的 IPC 的特性，来与 Android 中的 Binder 对比，以解析采用 Binder 的原因：</p><table><thead><tr><th align="center">特性</th><th align="left"></th></tr></thead><tbody><tr><td align="center">可靠性</td><td align="left">Android 中希望得到的是一种 Client-Service 的通信方式，而 Linux 中符合这种通信方式的只有 Socket。虽然可以在其他四种方式的基础上添加协议来控制，但这样会增加系统的复杂性，在手机这种条件复杂、资源稀缺的环境下，也难以保证可靠；</td></tr><tr><td align="center">传输性能</td><td align="left">虽然 Socket 是一个数据传输接口，但是性能开销大，适合网络传输、大文件传输这种重量级的传输环境；消息队列和管道采用的是存储-转发的形式，先把需要转发的数据拷贝到新开辟的内存缓存，然后再从内存缓存中把数据拷贝到接收方，经历了两次数据拷贝；共享内存虽然不用经过数据拷贝，多个进程共用一块内存，但是对于 Android 这种多应用进程、安全保密性高的场合，共享内存明显不合适；</td></tr><tr><td align="center">安全性</td><td align="left">Android 作为一个多应用的系统，各种应用的来源不同，确保各种应用的安全性是非常重要的。Linux 中传统的 IPC 完全没有任何的安全措施，完全依赖上层的协议来确保，具体有两种体现：第一，传统的 IPC 接收方无法获知发送方可靠的 UID/PID（用户ID/进程IP），从而无法鉴别对方的身份，使用传统的 IPC 只能由用户填入 UID/PID ，但这样不可靠，容易被恶意的程序利用；第二，传统IPC的访问接入点是开放的，无法建立私有通信，只要知道这些接入点的程序都可以和对端建立连接，这样无法阻止恶意程序通过猜测接收方的地址获得连接。</td></tr></tbody></table><h4 id="Binder-的组成"><a href="#Binder-的组成" class="headerlink" title="Binder 的组成"></a>Binder 的组成</h4><p>Binder 有四部分组成：Binder 客户端、Binder 服务端、Binder 驱动、服务登记查询模块。</p><table><thead><tr><th align="center">Binder 的组成</th><th align="center"></th></tr></thead><tbody><tr><td align="center">Binder 客户端</td><td align="center">Binder 客户端是想要使用服务的进程；（或者说是发送数据的进程）</td></tr><tr><td align="center">Binder 服务端</td><td align="center">Binder 服务端是实际提供服务的进程；</td></tr><tr><td align="center">Binder 驱动</td><td align="center">客户端拿到服务端的进程的一个 Binder 的对象引用，通过这个引用，直接调用对象的方法获取结果。在这个引用对象执行时，它是先将方法调用的请求转给 Binder 驱动；然后 Binder 驱动再将请求转给服务端进程；服务端进程收到请求后，调用服务端”真正”的对象来执行所要调用的方法；得出结果后，将结果发给 Binder 驱动；Binder 驱动再将结果发给我们的客户端；最终，我们在客户端进程的调用就有了返回值；</td></tr><tr><td align="center">Service Manager</td><td align="center">统一管理服务端的服务的管理器；首先服务端的 Service 启动时都需要在 Service Manager 登记注册，来告诉系统的其他进程那些服务可以提供服务，当客户端进程需要这个服务的时候，就去这个登记的地方通过查询来找到这个对象；</td></tr></tbody></table><p>上面表格总结的流程：</p><ul><li>客户端通过 Binder 引用拿到 Proxy 对象引用；（Proxy 是 client 用来发送数据的）；</li><li>客户端通过调用 Proxy 对象来调用服务端的方法；（实际这调用的过程中是通过 Binder 驱动来调用，然后通过 Binder 驱动返回结果）;</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.cnblogs.com/itgungnir/p/6640120.html">【Android - IPC】之Binder机制简介</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Binder-在不同的角度上的定义&quot;&gt;&lt;a href=&quot;#Binder-在不同的角度上的定义&quot; class=&quot;headerlink&quot; title=&quot;Binder 在不同的角度上的定义&quot;&gt;&lt;/a&gt;Binder 在不同的角度上的定义&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;从设备的角度来说，Binder 是一种虚拟的物理设备驱动，位于 /dev/binder 目录下；&lt;/li&gt;
&lt;li&gt;从 Android 的代码上来说，Binder 是 Android 中的一个类，实现了 IBinder 接口；&lt;/li&gt;
&lt;li&gt;从 IPC 角度来说，Binder 是 Android 中的的一种跨进程的通信方式，在 Linux 系统上没有；&lt;/li&gt;
&lt;li&gt;从Android Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager 和相应的 ManagerService 的桥梁；&lt;/li&gt;
&lt;li&gt;从 Android 应用层来说，Binder 是 client 和 service 进行通信的媒介，当 bindService() 的时候，service端会返回一个包含 service 端业务调用的 Binder 对象，通过这个 Binder 对象，client 端就可以获取到 service 端提供的服务或者数据了；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Android进阶" scheme="https://hndroid.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Android" scheme="https://hndroid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android进程间通信（IPC）机制Binder系列笔记（一）</title>
    <link href="https://hndroid.github.io/2019/11/25/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E6%9C%BA%E5%88%B6Binder%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hndroid.github.io/2019/11/25/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E6%9C%BA%E5%88%B6Binder%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2019-11-25T03:37:41.000Z</published>
    <updated>2021-06-20T11:52:16.127Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android 中不同进程的 Activity 或 Service 之间是如何通信的呢？这个问题就是本系列讲解的重点。</p></blockquote><span id="more"></span><h4 id="Android系统基于Linux内核"><a href="#Android系统基于Linux内核" class="headerlink" title="Android系统基于Linux内核"></a>Android系统基于Linux内核</h4><p>Linux 系统继承和兼容了丰富的 Unix 系统进程间通信（IPC）机制。</p><table><thead><tr><th align="center">Linux 通信方式</th><th align="left">定义</th></tr></thead><tbody><tr><td align="center">管道（pipe）</td><td align="left">一种最基本的IPC机制。内核使用环形队列机制，借助内核缓冲区（4K）实现。</td></tr><tr><td align="center">信号（signal）</td><td align="left">信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生。</td></tr><tr><td align="center">跟踪（trace）</td><td align="left">常用来跟踪进程执行时的系统调用和所接收的信号。在Linux系统中，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</td></tr></tbody></table><h4 id="Binder机制组成"><a href="#Binder机制组成" class="headerlink" title="Binder机制组成"></a>Binder机制组成</h4><p>分别是 Client、Server、Service Manager和 Binder 驱动程序。其中，Client、Server、Service Manager 运行在用户空间，而Binder 驱动程序运行在内核空间。</p><img style="margin-left:auto; margin-right:auto; display:block" src="http://baihonghua.cn/Binder%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.png" alt="Binder机制组成"><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li><strong>Client、Server、Service Manager 运行在用户空间，而 Binder 驱动程序运行在内核空间。</strong></li><li><strong>Service Manager 和 Binder 已经在 Android 系统中实现，开发者只需要按照约定好的规范实现 Client 和 Service；</strong></li><li>Binder 驱动程序提供设备文件 /dev/binder 与用户空间交互，Client、Service 和 Service Manager 通过 open 和 ioctl 文件操作函数与 Binder 驱动程序进行通信；</li><li>Client、Server 进程间地通信是通过 binder 驱动程序简介实现的；</li><li>Service Manager 是一个守护进程，用来管理 Service,并向 Client 提供查询 Service 接口的能力；</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://blog.csdn.net/luoshengyang/article/details/6618363">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a></p><p><a href="https://www.cnblogs.com/innost/archive/2011/01/09/1931456.html">Android深入浅出之Binder机制</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Android 中不同进程的 Activity 或 Service 之间是如何通信的呢？这个问题就是本系列讲解的重点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android进阶" scheme="https://hndroid.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Android" scheme="https://hndroid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java反射机制</title>
    <link href="https://hndroid.github.io/2019/11/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://hndroid.github.io/2019/11/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2019-11-25T03:20:48.000Z</published>
    <updated>2021-06-20T11:52:16.146Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在接触 Android 的组件化原理的时候，发现自己对 Java 反射的机制理解并不是很深，只能利用周末的时间把 Java 反射机制回炉重铸。</p><span id="more"></span><h4 id="什么是Java反射"><a href="#什么是Java反射" class="headerlink" title="什么是Java反射"></a>什么是Java反射</h4><p>反射机制是 Java 语言提供的一种基础功能，赋予了 Java 程序在运行时的自省（introspect，官方用语）的能力。通过 Java 的反射机制，程序员可以在 Java 程序在运行态的时候操作任意的类或者对象的属性、方法。利用 Java 的反射机制，可以做到以下：</p><ul><li>在程序的运行态可以获取对象所属的类；</li><li>在程序的运行态可以构造类的对象实例；</li><li>在程序的运行时可以获取，或者修改类的成员属性；</li><li>在程序的运行态可以调用某个类，或者对象的方法；</li><li>在程序的运行态可以获取类的其他信息，比如描述修饰符、父类信息等；</li></ul><blockquote><p>对文中的”自省”的理解：”自省”应该仅指程序在运行时对自身信息（元数据）的检测，而反射机制不仅仅需要在运行时对程序的自身数据进行检测，还需要根据检测到的数据修改程序的状态或者方法。</p></blockquote><p>用于操作反射的相关的 5 个类：</p><ul><li>java.lang.Class：代表类；</li><li>java.lang.reflect.Constructor：代表类的构造方法；</li><li>java.lang.reflect.Field：代表类的属性；</li><li>java.lang.reflect.Method：代表类的方法；</li><li>java.lang.reflect.Modifier：代表类、方法、属性的修饰符；</li></ul><p>Constructor、Field、Method 这三个类都继承 AccessibleObject，该对象有一个非常重要的方法 <code>AccessibleObject#setAccessible​(boolean flag)</code>，这里的所谓 accessible 可以理解成修饰成员的 public、protected、private，这意味着我们可以在程序运行时修改类成员的访问限制。</p><p>在类 Object 中有 <code>Object#getClass()</code>、<code>Object#hashCode()</code>、<code>Object#equals(Object obj)</code>、<code>Object#clone()</code>、<code>Object#toString()</code>、<code>Obect#notify()</code>、<code>Object#notifyAll()</code>、<code>Object#wait()</code> 等 public 权限的方法。而 <code>Object#getClass()</code> 方法则是返回程序运行时的 Class 类的对象实例。CLass 类也是同样继承 Object 类，拥有相应的方法。Class 类的类表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，一个注解是一个接口。每个数组还属于一个反映为Class对象的类，该对象由具有相同元素类型和维数的所有数组共享。Java 的基本类型 boolean、byte、char、short、int、long、float、double，和关键字 void 也表示为 Class 对象。</p><p>Class 没有 public 类型的构造器。Java 虚拟机会在加载类时以及通过在类加载器中调用 <code>ClassLoader#defineClass()</code> 方法来自动构造 Class 对象。</p><p>Modifier 类提供了 static 方法和常量来解码类和成员访问修饰符。修饰符集合被表示为具有不同修饰符的不同位置的整数。表示的范围有 abstract、final、interface、native、private、protected、public、strict、synchronized、transient、volatile。</p><h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><blockquote><p>java.lang.reflect.Constructor<T></T></p></blockquote><p>Constructor 提供了一个类的单个构造函数的信息和访问。Constructor 允许在将实际参数与 newINstance() 与底层构造函数的形式参数进行匹配时进行扩展转换，如果发生缩小转换，则抛出 <code>IllegalArgumentException</code>。</p><table><thead><tr><th align="left">方法</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Constructor&lt;?&gt;[] getConstructors()</td><td align="left">返回包含一个 Constructor 对象的数组，元素表示为所指定的类的所有的 public 权限的构造函数</td></tr><tr><td align="left">getDeclaredConstructors()</td><td align="left">表示返回包含 Constructor 对象的数组，元素表示为指定类的构造函数，包含非 public 权限的</td></tr><tr><td align="left">getConstructor(class&lt;?&gt;… parameterTypes)</td><td align="left">返回一个 Constructor 对象，表示指定参数的类的 public 权限的构造函数</td></tr><tr><td align="left">getDeclaredConstructor(class&lt;?&gt;… parameterTypes)</td><td align="left">表示返回一个表示 Constructor 对象，表示指定参数的构造函数，包含非 public 权限的</td></tr></tbody></table><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><blockquote><p>java.lang.reflect.Field</p></blockquote><p> Field 提供有关类或接口的单个字段的信息和动态访问。 反射的字段可以是类（静态）字段或实例字段。Field 允许在获取或设置访问操作期间扩展转换，但如果发生缩小转换，则抛出 <code>IllegalArgumentException</code>。 </p><table><thead><tr><th align="left">方法</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">getFields()</td><td align="left">返回包含一个数组 Field 对象，表示的类或接口的所有可访问的公共字段</td></tr><tr><td align="left">getDeclaredFields()</td><td align="left">返回包含一个数组 Field 对象，表示的类或接口声明的所有字段</td></tr><tr><td align="left">getField(String name)</td><td align="left">返回包含一个数组 Field 对象，表示的类或接口指定的可访问的公共字段</td></tr><tr><td align="left">getDeclaredField(String name)</td><td align="left">返回包含一个数组 Field 对象，表示的类或接口指定的任意权限的公共字段</td></tr></tbody></table><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><blockquote><p>java.lang.reflect.Method</p></blockquote><p>Method 提供有关类和接口上单一方法的信息和访问权限。 反映的方法可以是类方法或实例方法（包括抽象方法）。</p><table><thead><tr><th align="left">方法</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">getMethods()</td><td align="left">获取类所有的 public 方法</td></tr><tr><td align="left">getMethod(String name, class&lt;?&gt;… parameterTypes)</td><td align="left">获取类特定的 public 方法</td></tr><tr><td align="left">getDeclaredMethods()</td><td align="left">获取类所有的方法</td></tr><tr><td align="left">getDeclaredMethod(String name, class&lt;?&gt;… parameterTypes)</td><td align="left">获取类特定的方法</td></tr></tbody></table><h4 id="反射机制原理"><a href="#反射机制原理" class="headerlink" title="反射机制原理"></a>反射机制原理</h4><p>Java 虚拟机可以通过称为运行时类型信息（RTTI, Run Time Type Information）的技术在运行时检查任何类，这是通过一种称为 Class 对象的特殊对象完成的，该对象包含有关类的信息。</p><p>虚拟机为每个类管理一个独一无二的 Class 对象。也就是说，每个类都有一个 Class 对象实例。在运行程序的时候，JVM 首先需要会去检测所需加载的类的 Class 是否已经完成加载。如果没有加载在 JVM 中，那么 JVM 回去寻找对应类名的 .class 文件，完成对 Class 对象的加载。通过 Class 对象，我们可以实例化对应的 Class 类对象，调用其构造器（Constructor）、调用类的成员方法（Method）、访问或者修改类的成员属性（Field）。通过 <code>AccessibleObject#setAccessible​(boolean flag)</code> 可以访问到类的非 public 权限的其他成员，在上文提到通过 <code>AccessibleObject#setAccessible​(boolean flag)</code> 可以在程序运行时修改类成员的访问限制。实际上，<code>AccessibleObject#setAccessible​(boolean flag)</code> 关闭了权限的访问检查，使得通过 <code>Class#invoke()</code> 可以访问到任意权限的类成员。</p><h4 id="Java反射实践"><a href="#Java反射实践" class="headerlink" title="Java反射实践"></a>Java反射实践</h4><p><img src="http://baihonghua.cn/Reflect_1.png"></p><p><img src="http://baihonghua.cn/Reflect_2.png"></p><h4 id="Java反射调用内部类"><a href="#Java反射调用内部类" class="headerlink" title="Java反射调用内部类"></a>Java反射调用内部类</h4><p>Java 的内部类可分为普通内部类、静态内部类。JVM 在编译含有普通内部类的时候，默认会在构造方法中传入外部类对象的引用，这也是为什么内部类对象会持有外部类的引用。我们可以通过解析 .class 字节码来验证这一推论。</p><p><img src="http://baihonghua.cn/Reflect_4.png"></p><p>有上面的基础，我们可以推断出，在反射调用普通内部类的成员的时候，我们需要在普通内部类的构造方法中传入外部类的对象引用。而静态内部类由于不持有外部类的引用，因而不需要在其构造方法中传入外部类的引用。</p><p>举个例子。有一个类 <code>OutClass</code>，然后 <code>OutClass</code> 含有一个普通内部类 <code>InnerClass</code>、以及静态内部类 <code>StaticClass</code>。我们通过反射分别实例化它们的时候，如下图:</p><p><img src="http://baihonghua.cn/Reflect_6.png"></p><p>反射调用普通内部类和静态内部类，只是在实例化的构造器的时候有区别，对于调用内部类的 Field、Method、Constructor，其过程是和调用普通类的过程时一样的，在这里就不一一细述了（主要因为我懒）。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Java 的反射机制用起来挺复杂的。但 Java 的反射机制在 Android 组件化中解耦合起到了很大的作用。可以在程序运行时访问类的成员属性或修改属性、执行方法、以及执行构造方法。并且在 Android 的许多源码中，有很多的属性、方法被标记了 @hide，但通过 Java 的反射，仍然可以访问这些属性、方法。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近在接触 Android 的组件化原理的时候，发现自己对 Java 反射的机制理解并不是很深，只能利用周末的时间把 Java 反射机制回炉重铸。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="https://hndroid.github.io/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="https://hndroid.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap里面的hashcode()</title>
    <link href="https://hndroid.github.io/2019/10/23/HashMap%E9%87%8C%E9%9D%A2%E7%9A%84hashcode()%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hndroid.github.io/2019/10/23/HashMap%E9%87%8C%E9%9D%A2%E7%9A%84hashcode()%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-10-23T05:01:55.000Z</published>
    <updated>2021-06-20T11:52:16.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在聊 <code>hashcode()</code> 的作用之前，我们首先需要了解什么是散列表。散列表是一种数据结构，它的英文名称叫 <code>Hash Table</code>, 也是我们平常称的’哈希表’，或者 ‘Hash表’。散列表是一种支持利用数组下标实现随机访问的数据结构，也可以理解成散列表是一种数组的扩展。</p><span id="more"></span><p>下面我举个例子解析一下，在某次校运动会有 100 名选手参加，为了便于记录他们每个选手的成绩，选手会依次被贴上属于自己的号码编号。假设他们的编号是 1 到 100 依次编号。现在我们需要通过编程的方式，怎样才可以快速地拿到指定编号选手的成绩呢？</p><p>通常我们会构建一个一维数组，然后把编号为 1 的选手信息放在下标为 0 的数组位置、把编号为 2 的选手信息放在下标为 1 的数组位置，以此类推，把编号为 100 的选手信息放在数组下标为 99 的位置里面。当我们现在想拿到编号为 x 的选手信息，我们只需要在数组下标为 y 的位置把选手的信息拿出来就可以的，这个取选手的信息的过程的时间复杂度为 O(1), 这样子的效率是不是很高？</p><blockquote><p>扩展：为什么数组根据数组下标的随机访问可以做到时间复杂度为 O(1) 呢？</p></blockquote><p>实际上，这个例子已经包含了散列思想了。在这个例子中，选手编码 x 和数组下标 y 可以组成的表达式：</p><div align="center"><img src="http://baihonghua.cn/%E5%85%AC%E5%BC%8F.png"></div><p>其中，运动员选手的编号我们叫做键（key）或者关键字。我们用来标识一个选手。然后我们把参赛编号转化为数组下标的映射方法就叫做散列函数（或者 Hash函数、哈希函数），而散列函数计算得到的值就叫做散列值（或者 Hash 值、哈希值）。</p><p>由上面的例子，我们可以总结出这样的规律：散列表用的就是数组支持按照下标随机访问的时候，时间复杂度为 O(1) 的特性。我们通过散列表函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们需要查询数组的元素的时候，同样需要把元素的键值通过散列函数映射成对应的数组下标，然后通过数组的下标找到对应的元素。</p><h4 id="HashMap-如何实现查询-Value-的高效性"><a href="#HashMap-如何实现查询-Value-的高效性" class="headerlink" title="HashMap 如何实现查询 Value 的高效性"></a>HashMap 如何实现查询 Value 的高效性</h4><p>在聊 HashMap 如何实现查询 Value 的高效性之前，我们先复习一下在线性表里面查询一个指定的元素，假设这个线性表的长度为 1000，如果顺序查找，那么最差的时间复杂度为 O(1000)，而采用二分查找，最差的时间复杂度也是需要 O(500)。</p><p>而在 HashMap 中，则是非常依赖于哈希码的有效性。在 HashMap 内部的结构，它可以看作是数组（Node&lt;K,V&gt;[] table）和链表结合组成的复合结构。并且放在 HashMap 中的数据和 HashMap 的内部结构中的数组是通过 hash() 相互关联的。</p><p>我们还是拿上面运动会的例子说明，假设一个 hash() 的表达式为 x-1, 变换成数学公式里面的 y = f(x), 其中 f(x) = x - 1（其中 x 表示的是选手的编号，y 表示的是数组的下标）。当我们知道某个选手的编号为 1，那么我们只需要通过该对应的 hash() 函数转换，即 1 - 1 = 0，那么得到的 0 便是数组的下标，那么我们就可以很快地得到编号为 1 的选手成绩信息。同样地，如果我们需要储存编号为 50 的选手成绩信息，那么我们只需要把 50 代进 hash() 里面，即 50 - 1 = 49，得到的 49 就是编号为 50 的选手可以储存的位置，效果如下图：</p><p><img src="http://baihonghua.cn/%E6%A1%B6%E6%95%B0%E7%BB%84.png"></p><p>当然，在实际的 HashMap 中，hash() 可不是如上面的 <code>f(x) = x - 1</code> 一样简单。如下图(Java OpenJdk 11)：</p><p><img src="http://baihonghua.cn/carbon%20%285%29.png"></p><p>由上图观察可知，HashMap 里面的散列表数组下标的确定，有桶数组的长度 <code>n</code> 以及 <code>hash()</code> 函数确定。在 HashMap 中，但我们需要存储一对键值对的时候，我们需要把对应的键值装进 <code>hash(Object key)</code> 里面，转换成对应的哈希值以后，在通过与桶数组长度的运算，得到对应的桶数组下标，然后把对应的 Value 值存储在指定的数组下标的位置。同样地，如果我们根据键值得到 HashMap 中对应的 Value，那么我们需要进行存储的逆运算即可。</p><h4 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h4><p>在实现 HashMap 的存和取操作之前，我们需要解决 HashMap 的哈希碰撞。我们知道，哈希算法是无法做到零冲突的，也就是说哈希算法存在哈希碰撞。这里基于组合数学里面的一个非常基础的理论，鸽巢原理（也叫抽屉原理）。这个原理描述的是如果有 10 个鸽巢，有 11 个鸽子，那么肯定有一个鸽巢中的鸽子数量是多于 1 个，换而言之，肯定存在着有 2 个鸽子在同一个鸽巢里面。</p><p>为了解决哈希碰撞，人们提出了两种主要的解决方法，开发寻址法和链表法。而 HashMap 主要采用了链表法解决哈希冲突。HashMap 解决哈希冲突的模型如下图：</p><div align="center"><img src="http://baihonghua.cn/HashMap%E9%93%BE%E8%A1%A8%E6%B3%95%E6%A8%A1%E5%9E%8B.png"></div><p>HashMap 的默认初始的桶数组大小为 16，而当产生哈希碰撞的时候，则把发生碰撞的值添加到链表中。在 JDK1.8 中，当链表的长度大于 8 的时候，链表就会转换为红黑树，利用红黑树快速增删查改的特性，从而优化提高 HashMap 的效率。同时，当链表的长度再次少于 8 的时候，红黑树又会转化为链表，因为红黑树需要维护平衡，在链表的个数比较少的时候，对 HashMap 提高的效率并不明显。</p><h4 id="在重写-hashcode-的时候，为什么需要重写-equals"><a href="#在重写-hashcode-的时候，为什么需要重写-equals" class="headerlink" title="在重写 hashcode() 的时候，为什么需要重写 equals()?"></a>在重写 hashcode() 的时候，为什么需要重写 equals()?</h4><p>有了上面的基础知识作为铺垫，有助于我们更好地理解在重写 hashcode() 的时候，为什么需要重写 equals() 方法。</p><p>在使用 HashMap 的时候，我们需要调用 HashMap 的 public 方法 <code>put(K key, V value)</code>, 把键值对传进到 HashMap 的实例里面（<code>在这篇文章里面约定，把传进 HashMap 的键值对，分别称为&quot;键值&quot;、Value值</code>）。如下图：</p><div align="center"><img src="http://baihonghua.cn/carbon%20%287%29.png"></div><p>如上面的代码，我们自定义了键值 <code>IKey</code> 类, 类 <code>IKey</code> 很简单，如上图代码 17 行起。并在第 4 和 第 5 行分别创建了 <code>IKey</code> 的对象 <code>mIkey_1</code> 、 <code>mIkey_2</code>，并通过 HashMap 的实例调用 <code>put()</code> 函数把 <code>mIkey_1</code> 作为键值传进，然后通过调用 <code>get()</code> 函数打印键值为 <code>mIkey_2</code> 的 Value 值。按照我们的需求，通过调用 <code>get()</code> 函数打印键值为 <code>mIkey_2</code> 的 Value 值应该是 <code>I am Key_1</code> 所对应的键值对的 Value，因为我们传进 <code>Ikey</code> 里面的 <code>id</code> 值同都是 5，那么我们通过 <code>mIkey_2</code> 获取到的 <code>Value</code> 值也应该和传进的 <code>mIkey_1</code> 相同。然而经过控制台打印的结果却截然出乎我们的预料，控制台打印出的为 <code>null</code>，这是为什么呢？</p><p>因为我们在自定义 HashMap 的时候，没有重写 <code>hashcode()</code> 函数，导致我们通过 <code>mIkey_2</code> 键值去获取 <code>mIkey_1</code> 传进的 Value 值的时候，直接调用了 Objct 类里面的 <code>hashcode()</code> 函数，我们知道 Object 类里面的 <code>hashcode()</code> 返回的是关于 IKey 对象实例内存地址（有可能为内存地址的哈希值，不同的 JDK 版本略有不同，这里暂不做考究，感兴趣的读者可自行翻阅 Object 的源码阅读，为了便于理解，我在这篇文章中认为 Object 类里面的 hashcode() 方法返回的是对象的内存地址）。</p><p>显然地，<code>IKey</code> 的对象两个实例 <code>mIkey_1</code> 、 <code>mIkey_2</code> 在虚拟机内存中的地址是不同的，那么 HashMap 通过 <code>mIkey_2</code> 去查询 <code>mIkey_1</code> 的 Value 值的时候，因为不存在 <code>mIkey_2</code> 的内存地址的 key 值，于是控制台返回的结果为 <code>null</code>。</p><div align="center"><img src="http://baihonghua.cn/carbon%20%288%29.png"></div><p>如上图，我们在自定义的键值 <code>IKey</code> 中重写了 <code>hashcode()</code> 方法，但我们此时运行 IhashMap 中的 main 方法，那么这时候控制台打印的会是 “I am key_1” 吗？</p><p>答案是否定的，在控制台打印输出的同样是 <code>null</code>。因为在 HashMap 中调用 <code>get()</code> 函数时，首先会通过 <code>mIkey_2</code> 的哈希值计算出 <code>mIkey_2</code> 在桶数组的位置下标，如果该位置下标的数组元素存在，再次判断该元素的哈希值是否与  <code>mIkey_2</code> 的哈希是否相同。我们前面提到，哈希算法无法做到零冲突。也就是说即使两个不同的 IKey 对象实例也可能存在着相同的哈希值。因此，在前面两个条件都成立的前提下，还需要调用 IKey 的 <code>equals()</code> 方法，判断里面的 <code>id</code> 是否相同。如果 <code>id</code> 的值相同，那么才可以通过 <code>mIkey_2</code> 为键值找到通过 <code>mIkey_1</code> 传进的键值。但是我们没有重写到 <code>equals()</code> 方法，故 HashMap 调用的是 Object 类的 <code>equals()</code> 方法。</p><p>我们知道，Object 类中的 <code>equals()</code> 方法比较的是两个对象的内存地址。显然，<code>mIkey_1</code> 和 <code>mIkey_2</code> 的内存地址是不同的，因此我们在重写 <code>hashcode()</code> 方法了，但是没有重写到 <code>equals()</code> 的情况下，通过 <code>mIkey_2</code> 为键值去查询 <code>mIkey_1</code> 的 Value 值，仍然为 <code>null</code>。</p><p>再看上图，当我们把 IKey 中已经注释的 <code>equals()</code> 注释掉，那么我们在控制台得到的结果，就是我们想要的 <code>I am Key_1</code>。</p><h4 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h4><p>到了这里，可能你会想问，为什么平常我在 HashMap 中使用 Integer、String 等作为键值的时候，不需要重写 <code>hashcode()</code> 和 <code>equals()</code> 方法呢？ 这是因为 Java 工程师已经帮我们重写并且实现好了这两个方法。有兴趣的读者可以自行翻阅它们的源码查看。</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul><li><a href="https://www.ituring.com.cn/book/875">谢路云 《算法（第四版）》</a></li><li><a href="https://book.douban.com/subject/30295940/">袁春风 余子濠 《计算机系统基础 第二版》</a></li><li><a href="https://time.geekbang.org/column/intro/100006701">杨晓峰 《Java核心技术36讲》</a></li><li><a href="https://time.geekbang.org/column/intro/100017301">王争 《数据结构与算法之美》</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在聊 &lt;code&gt;hashcode()&lt;/code&gt; 的作用之前，我们首先需要了解什么是散列表。散列表是一种数据结构，它的英文名称叫 &lt;code&gt;Hash Table&lt;/code&gt;, 也是我们平常称的’哈希表’，或者 ‘Hash表’。散列表是一种支持利用数组下标实现随机访问的数据结构，也可以理解成散列表是一种数组的扩展。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="https://hndroid.github.io/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="https://hndroid.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>View绘制流程</title>
    <link href="https://hndroid.github.io/2019/10/17/View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>https://hndroid.github.io/2019/10/17/View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</id>
    <published>2019-10-17T02:03:01.000Z</published>
    <updated>2021-06-20T11:52:16.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于 Android 源码 5.1 分析</p></blockquote><span id="more"></span><h4 id="把布局添加进-DecorView"><a href="#把布局添加进-DecorView" class="headerlink" title="把布局添加进 DecorView"></a>把布局添加进 DecorView</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">//--&gt;源码 1</span></span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Set the activity content from a layout resource.  The resource will be</span></span><br><span class="line"><span class="comment">* inflated, adding all top-level views to the activity.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> layoutResID Resource ID to be inflated.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #setContentView(android.view.View)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//源码 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取 Window 的对象，并把布局资源放进 window 里面；</span></span><br><span class="line">    <span class="comment">//--&gt;源码 2</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位于 PhoneWindow 源码</span></span><br><span class="line"><span class="comment">//源码 2</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">    <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">    <span class="comment">// before this happens.</span></span><br><span class="line">    <span class="comment">// mContentParent 是 window 的顶级的 View，是 DecorView ；</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 PhoneWindow 实例的 DecorView 实例为空，则创建DecorView 实例，---&gt;源码 3</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="comment">//如果 PhoneWindow 实例的 DecorView 实例不为空，则移除所有的 View；</span></span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        view.setLayoutParams(params);</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = <span class="keyword">new</span> Scene(mContentParent, view);</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mContentParent.addView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码 3</span></span><br><span class="line"><span class="comment">//主要是创建一个 DecorView 实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 生成DecorView ---&gt;源码4</span></span><br><span class="line">        mDecor = generateDecor(); </span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 为 DecorView 设置布局格式并且返回 mContentParent</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//---&gt;&gt; 源码 5</span></span><br><span class="line">        mContentParent = generateLayout(mDecor); </span><br><span class="line">        ...</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码 4：generateDecor()</span></span><br><span class="line"><span class="comment">  * 作用：生成DecorView</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*源码 5 generateLayout()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Apply data from current theme.</span></span><br><span class="line">        <span class="comment">//1. 获取该 window 主题对应的属性</span></span><br><span class="line">        TypedArray a = getWindowStyle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inflate the window decor.</span></span><br><span class="line">        <span class="comment">//2. 加载窗口的布局特性</span></span><br><span class="line">        <span class="keyword">int</span> layoutResource;</span><br><span class="line">        <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">        <span class="comment">// System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 加载layoutResource</span></span><br><span class="line">        View in = mLayoutInflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 往DecorView中添加子View</span></span><br><span class="line">        <span class="comment">// 即文章开头介绍DecorView时提到的布局格式，那只是一个例子，根据主题样式不同，加载不同的布局。</span></span><br><span class="line">        decor.addView(in, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); </span><br><span class="line">        mContentRoot = (ViewGroup) in;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 这里获取的是mContentParent = 即为内容栏（content）对应的DecorView = FrameLayout子类</span></span><br><span class="line">        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>创建 Window 抽象类的子类 PhoneWindow 类的实例对象；</li><li>为 PhoneWindow 类对象设置 WindowManager 对象；</li><li>为 PhoneWindow 类对象创建 DecorView 对象；</li><li>为 DecorView 类对象中的 content 增加 Activity 中的布局文件；</li></ol><h4 id="执行绘制三大步前的准备"><a href="#执行绘制三大步前的准备" class="headerlink" title="执行绘制三大步前的准备"></a>执行绘制三大步前的准备</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码 1</span></span><br><span class="line"><span class="comment">//位于 ActivityThread 中，也就是在主线程创建的时候，会调用 handleResumeActivity()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// If the window hasn&#x27;t yet been added to the window manager,</span></span><br><span class="line">    <span class="comment">// and this guy didn&#x27;t finish itself or start another activity,</span></span><br><span class="line">    <span class="comment">// then go ahead and add the window.</span></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        <span class="comment">//1. window 是 PhoneWindow 的实例;</span></span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        <span class="comment">//2. r.window.getDecorView() 返回的是 DecorView 的实例;</span></span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        <span class="comment">//3. DecorView 对用户不可见;</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. DecorView被添加进WindowManager了,此时，不可见</span></span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//---&gt;源码 2</span></span><br><span class="line">            wm.addView(decor, l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">    <span class="comment">// we started another activity, then don&#x27;t yet make the</span></span><br><span class="line">    <span class="comment">// window visible.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">            TAG, <span class="string">&quot;Launch &quot;</span> + r + <span class="string">&quot; mStartedActivity set&quot;</span>);</span><br><span class="line">        r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The window is now visible if it has been added, we are not</span></span><br><span class="line">    <span class="comment">// simply finishing, and we are not starting another activity.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">            &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        <span class="comment">//4. DecorView 对用户可见</span></span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码 2</span></span><br><span class="line"><span class="comment">//位于 WindowManagerImpl 中，实现了 WindowManager</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> view The view to be added to this window.  传入的是 DecorView 的实例；</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> params The LayoutParams to assign to view.  传入的是 PhoneWindow 的 params</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    <span class="comment">//mGlobal 是 WindowManagerGlobal 的实例，---&gt;源码 3</span></span><br><span class="line">    mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码 3</span></span><br><span class="line"><span class="comment">//位于 WindowManagerGlobal 中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">    <span class="comment">//最后执行此操作是因为它会触发启动操作的消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//---&gt;源码 4，这里的 root 表示 ViewRootImpl 的实例；然后 wparams 表示的是 PhoneWindow 的实例；</span></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位于 ViewRootlmpl </span></span><br><span class="line"><span class="comment">//源码 4</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* We have one child</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line">            ···</span><br><span class="line">            <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">            <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">            <span class="comment">// any other events from the system.</span></span><br><span class="line">            <span class="comment">//---&gt;源码 5</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位于 ViewRootlmpl</span></span><br><span class="line"><span class="comment">//源码 5</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        <span class="comment">//判断是否是当前线程</span></span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//---&gt;源码 6</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位于 ViewRootlmpl</span></span><br><span class="line"><span class="comment">//源码 6</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().postSyncBarrier();</span><br><span class="line">        <span class="comment">// 通过mHandler.post（）发送一个runnable，在run()方法中去处理绘制流程</span></span><br><span class="line">        <span class="comment">// 与ActivityThread的Handler消息传递机制相似</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">            <span class="comment">//---&gt;源码 7，主要往接口 mTraversalRunnable 看</span></span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位于 ViewRootlmpl</span></span><br><span class="line"><span class="comment">//源码 7</span></span><br><span class="line">··· </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable(); </span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//---&gt;源码 8</span></span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;performTraversals&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//---&gt;源码 9</span></span><br><span class="line">            performTraversals();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码 9</span></span><br><span class="line"><span class="comment">//performTraversals() 进入了 performMeasure()、performLayout()、performDraw() 绘制的的三大步；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cache mView since it is used so much below...</span></span><br><span class="line">        <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                    (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                    || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123;</span><br><span class="line">                <span class="comment">//根据 DecorView 的宽高、和 DecorView 的布局参数合成 ChildMeasureSpec；</span></span><br><span class="line">                <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//传入的参数说明，View 的绘制流程从顶级 DecorView 开始，然后一层一层从 ViewGoroup 至子 View 遍历测绘； </span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Implementation of weights from WindowManager.LayoutParams</span></span><br><span class="line">                <span class="comment">// We just grow the dimensions as needed and re-measure if</span></span><br><span class="line">                <span class="comment">// needs be</span></span><br><span class="line">                <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">                <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(TAG,</span><br><span class="line">                            <span class="string">&quot;And hey let&#x27;s measure once more: width=&quot;</span> + width</span><br><span class="line">                            + <span class="string">&quot; height=&quot;</span> + height);</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                layoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not the first pass and no window/insets/visibility change but the window</span></span><br><span class="line">        <span class="comment">// may have moved and we need check that and if so to update the left and right</span></span><br><span class="line">        <span class="comment">// in the attach info. We translate only the window frame since on window move</span></span><br><span class="line">        <span class="comment">// the window manager tells us only for the new frame but the insets are the</span></span><br><span class="line">        <span class="comment">// same and we do not want to translate them more than once.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Well, we are checking whether the frame has changed similarly</span></span><br><span class="line">        <span class="comment">// to how this is done for the insets. This is however incorrect since</span></span><br><span class="line">        <span class="comment">// the insets and the frame are translated. For example, the old frame</span></span><br><span class="line">        <span class="comment">// was (1, 1 - 1, 1) and was translated to say (2, 2 - 2, 2), now the new</span></span><br><span class="line">        <span class="comment">// reported frame is (2, 2 - 2, 2) which implies no change but this is not</span></span><br><span class="line">        <span class="comment">// true since we are comparing a not translated value to a translated one.</span></span><br><span class="line">        <span class="comment">// This scenario is rare but we may want to fix that.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> windowMoved = (mAttachInfo.mWindowLeft != frame.left</span><br><span class="line">                || mAttachInfo.mWindowTop != frame.top);</span><br><span class="line">        <span class="keyword">if</span> (windowMoved) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateRectInScreenToAppWinFrame(frame);</span><br><span class="line">            &#125;</span><br><span class="line">            mAttachInfo.mWindowLeft = frame.left;</span><br><span class="line">            mAttachInfo.mWindowTop = frame.top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; !mStopped;</span><br><span class="line">    <span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">            || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!skipDraw || mReportNextDraw) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            performDraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// Try again</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mIsInTraversal = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码流程总结"><a href="#源码流程总结" class="headerlink" title="源码流程总结"></a>源码流程总结</h4><ol><li>把 DecorView 对象实例装进 WindowManger 里面；</li><li>WindowManager 再把 DecorView 对象实例装进到 ViewRootImpl 里面；</li><li>ViewRootImpl 对象通过 Handler 向主线程发送信息，通知 doTraversal() –&gt; performTraversals() 开始执行绘制的三大步；</li></ol><h4 id="绘制前的准备"><a href="#绘制前的准备" class="headerlink" title="绘制前的准备"></a>绘制前的准备</h4><p><img src="http://baihonghua.cn/%E7%BB%98%E5%88%B6%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87.png"></p><blockquote><p>ViewRootImpl 对象中接收各种的变化（如来自 WMS 的窗口属性变化、来自控件树的尺寸变化、重绘请求等都会引发 performTraversals() 的调用）并且在 ViewRootImpl 的对象中完成；</p></blockquote><h4 id="DecorView-添加到窗口-Window-的过程"><a href="#DecorView-添加到窗口-Window-的过程" class="headerlink" title="DecorView 添加到窗口 Window 的过程"></a>DecorView 添加到窗口 Window 的过程</h4><p><img src="http://baihonghua.cn/DecorView%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%AA%97%E5%8F%A3Window%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基于 Android 源码 5.1 分析&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="View体系" scheme="https://hndroid.github.io/categories/View%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="Android" scheme="https://hndroid.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
